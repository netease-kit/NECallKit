import { NECallParam, NECallType, NECallPushConfig, NESelfInfo, NERecordProvider, NERecordConfig, NERtcCallStatus } from '@necallkit/callkit/src/main/ets/api/Models';
import { NECallEngine, NECallUI } from '@necallkit/callkit_ui';
import { CallState } from '@necallkit/callkit_ui/src/main/ets/impl/CallState';
import { CallManager } from '@necallkit/callkit_ui/src/main/ets/impl/CallManager';
import common from '@ohos.app.ability.common';
import router from '@ohos.router';
import { BeautyDataService, BeautyFilterView, BeautyShapeView, BeautySkinView, VideoFuRender } from 'faceunity';
import { NERtcConstants, NERtcSDK, NERtcVideoView } from '@nertc/nertc_sdk';
import { BaseEffectTabs,
  BytedRender,
  ComposerNode, EffectManagerData, EffectTabsController, TabItem  } from 'byteeffect'
import { NEErrorCode } from '@necallkit/callkit';
import { CallSettingsManager } from '../manager/CallSettingsManager';
import { CallRecord } from '../service/CallRecord';
import { CallRecordServiceImpl } from '../service/CallRecordServiceImpl';
import { CallRecordStorage } from '../service/CallRecordStorage';
import { RecordUtils } from '../utils/RecordUtils';
import { UserModel } from '../viewmodel/UserModel';
import { V2NIMMessage, V2NIMMessageService } from '@nimsdk/base';
import promptAction from '@ohos.promptAction';

/**
 * è‡ªå®šä¹‰è¯å•å®ç°
 */
class TestRecordProvider implements NERecordProvider {
  private tag: string = 'TestRecordProvider';

  onRecordSend(config: NERecordConfig): void {
    const callTypeStr = config.callType === NECallType.AUDIO ? 'éŸ³é¢‘' : 'è§†é¢‘';
    const callStateStr = this.getCallStateString(config.callState);
    
    const message = `è¯å•å›è°ƒè§¦å‘:\næ¥æ”¶è€…: ${config.accId}\né€šè¯ç±»å‹: ${callTypeStr}\né€šè¯çŠ¶æ€: ${callStateStr}`;
    
    console.info(`[${this.tag}] ${message}`);
    
    // æ˜¾ç¤ºæç¤ºä¿¡æ¯
    promptAction.showToast({
      message: message,
      duration: 3000,
      bottom: 200
    });
  }

  private getCallStateString(state: NERtcCallStatus): string {
    switch (state) {
      case NERtcCallStatus.COMPLETED:
        return 'é€šè¯å®Œæˆ';
      case NERtcCallStatus.CANCELED:
        return 'é€šè¯å–æ¶ˆ';
      case NERtcCallStatus.REJECTED:
        return 'é€šè¯æ‹’ç»';
      case NERtcCallStatus.TIMEOUT:
        return 'è¶…æ—¶æœªæ¥å¬';
      case NERtcCallStatus.BUSY:
        return 'å¯¹æ–¹å¿™çº¿';
      default:
        return `æœªçŸ¥(${state})`;
    }
  }
}

/**
 * Resource å¯¹è±¡æ¥å£ï¼Œç”¨äºè®¿é—®èµ„æºID
 */
interface ResourceWithId {
  id?: number;
}

/**
 * æœ¬åœ° AlertDialog æŒ‰é’®é…ç½®ç±»å‹ï¼ˆä¸ AlertDialogButtonOptions ç»“æ„å¯¹é½ï¼‰
 */
interface LocalAlertDialogButtonOptions {
  value: string;
  action: () => void;
}

@Entry
@Component
export struct SingleCallPage {
  @State targetAccountId: string = '';
  @State callType: NECallType = NECallType.AUDIO;
  @State callRecords: CallRecord[] = [];

  // @State FuBeautyType: config.FUBeautyType = config.FUBeautyType.Skin;
  private fuRender: VideoFuRender|null = null
  private bytedRender: BytedRender|null = null
  private callSettingsManager: CallSettingsManager = new CallSettingsManager();
  private callRecordService: CallRecordServiceImpl | null = null;
  private receiveMessageHandler: ((messages: V2NIMMessage[]) => void) | null = null;
  private sendMessageHandler: ((message: V2NIMMessage) => void) | null = null;
  private testRecordProvider: TestRecordProvider | null = null;

  /**
   * è·å–UserModelå®ä¾‹
   */
  getUserModel(): UserModel {
    return UserModel.getInstance(getContext(this));
  }

  /**
   * è·å–å›½é™…åŒ–å­—ç¬¦ä¸²
   * @param resId èµ„æºå¯¹è±¡
   * @returns å›½é™…åŒ–å­—ç¬¦ä¸²
   */
  private getString(resId: Resource): string {
    try {
      const context = getContext(this) as common.UIAbilityContext;
      if (context && context.resourceManager) {
        // Resource å¯¹è±¡æœ‰ id å±æ€§ï¼Œä½¿ç”¨ç±»å‹æ–­è¨€è®¿é—®
        const resourceObj = resId as ResourceWithId;
        if (resourceObj.id !== undefined) {
          return context.resourceManager.getStringSync(resourceObj.id);
        }
      }
    } catch (error) {
      console.error(`[SingleCall] getString error:`, error);
    }
    return '';
  }

  async aboutToAppear(): Promise<void> {
    const context = getContext(this) as common.UIAbilityContext;
    // åˆå§‹åŒ–é€šè¯è®°å½•æœåŠ¡
    await this.initCallRecordService(context);

    // åŠ è½½é€šè¯è®°å½•
    await this.loadCallRecords();

    // æ³¨å†Œæ¶ˆæ¯ç›‘å¬
    this.registerMessageListeners();
  }

  async onPageShow(): Promise<void> {
    const context = getContext(this) as common.UIAbilityContext;
    // æ¯æ¬¡é¡µé¢å‡ºç°æ—¶éƒ½é‡æ–°åŠ è½½è®¾ç½®ï¼Œç¡®ä¿ä½¿ç”¨æœ€æ–°å€¼
    await this.callSettingsManager.loadSettings(context);

    // ç­‰å¾…åŠ è½½å®Œæˆåå†åº”ç”¨å¼•æ“çº§åˆ«çš„è®¾ç½®
    this.applySettings();
  }


  aboutToDisappear(): void {
    this.enableBytedEffectBeauty(false)
    this.enableFuLiveBeauty(false)
    // å–æ¶ˆæ¶ˆæ¯ç›‘å¬
    this.unregisterMessageListeners();
  }

  build() {
    Column() {
      // é¡¶éƒ¨å¯¼èˆªæ 
      Row() {
        // è¿”å›æŒ‰é’®
        Text('â†')
          .fontSize(24)
          .fontColor('#182431')
          .width(40)
          .height(40)
          .textAlign(TextAlign.Center)
          .onClick(() => {
            router.back();
          })

        // æ ‡é¢˜
        Text(this.getString($r('app.string.single_call_page_title')))
          .fontSize(18)
          .fontWeight(FontWeight.Medium)
          .fontColor('#182431')
          .layoutWeight(1)
          .textAlign(TextAlign.Center)

        // é€šè¯è®¾ç½®æŒ‰é’®
        Text(this.getString($r('app.string.single_call_settings_button')))
          .fontSize(16)
          .fontColor('#007DFF')
          .width(80)
          .textAlign(TextAlign.End)
          .onClick(() => {
            router.pushUrl({
              url: 'pages/SettingsPage'
            }).catch((err: Error) => {
              console.error('è·³è½¬åˆ°è®¾ç½®é¡µé¢å¤±è´¥:', err);
            });
          })
      }
      .width('100%')
      .height(56)
      .backgroundColor('#FFFFFF')
      .justifyContent(FlexAlign.SpaceBetween)
      .alignItems(VerticalAlign.Center)
      .padding({ left: 16, right: 16 })

      // å†…å®¹åŒºåŸŸ
      Column() {
          // ç”¨æˆ·IDè¾“å…¥åŒºåŸŸ
          Row() {
            Text(this.getString($r('app.string.single_call_target_account_label')))
              .fontSize(16)
              .fontColor('#182431')
              .width(80)

            TextInput({ placeholder: this.getString($r('app.string.single_call_target_account_placeholder')), text: this.targetAccountId })
              .layoutWeight(1)
              .height(40)
              .backgroundColor('#F5F5F5')
              .borderRadius(8)
              .padding({ left: 12, right: 12 })
              .onChange((value: string) => {
                this.targetAccountId = value;
              })
          }
          .width('100%')
          .padding({
            left: 16,
            right: 16,
            top: 20,
            bottom: 20
          })
          .alignItems(VerticalAlign.Center)

          // åª’ä½“ç±»å‹é€‰æ‹©åŒºåŸŸ
          Row() {
            Text(this.getString($r('app.string.single_call_type_label')))
              .fontSize(16)
              .fontColor('#182431')
              .width(80)

            Row() {
              // è§†é¢‘é€šè¯é€‰é¡¹
              Row() {
                Radio({ value: 'video', group: 'callType' })
                  .checked(this.callType === NECallType.VIDEO)
                  .onChange((isChecked: boolean) => {
                    if (isChecked) {
                      this.callType = NECallType.VIDEO;
                    }
                  })
                Text(this.getString($r('app.string.single_call_type_video')))
                  .fontSize(16)
                  .fontColor('#182431')
                  .margin({ left: 8 })
              }
              .onClick(() => {
                this.callType = NECallType.VIDEO;
              })
              .margin({ right: 24 })

              // è¯­éŸ³é€šè¯é€‰é¡¹
              Row() {
                Radio({ value: 'audio', group: 'callType' })
                  .checked(this.callType === NECallType.AUDIO)
                  .onChange((isChecked: boolean) => {
                    if (isChecked) {
                      this.callType = NECallType.AUDIO;
                    }
                  })
                Text(this.getString($r('app.string.single_call_type_audio')))
                  .fontSize(16)
                  .fontColor('#182431')
                  .margin({ left: 8 })
              }
              .onClick(() => {
                this.callType = NECallType.AUDIO;
              })
            }
            .layoutWeight(1)
            .justifyContent(FlexAlign.Start)
            .alignItems(VerticalAlign.Center)
          }
          .width('100%')
          .padding({ left: 16, right: 16, bottom: 20 })
          .alignItems(VerticalAlign.Center)

          // é€šè¯è®°å½•åŒºåŸŸ
          Column() {
            Row() {
              Text(this.getString($r('app.string.single_call_history_title')))
                .fontSize(16)
                .fontColor('#182431')
                .fontWeight(FontWeight.Medium)
                .layoutWeight(1)

              if (this.callRecords.length > 0) {
                Text(this.getString($r('app.string.single_call_history_clear')))
                  .fontSize(14)
                  .fontColor('#007DFF')
                  .onClick(() => {
                    this.clearCallRecords();
                  })
              }
            }
            .width('100%')
            .margin({ bottom: 16 })

            if (this.callRecords.length === 0) {
              Text(this.getString($r('app.string.single_call_history_empty')))
                .fontSize(14)
                .fontColor('#8E8E93')
                .width('100%')
                .textAlign(TextAlign.Center)
                .margin({ top: 40, bottom: 40 })
            } else {
              List() {
                ForEach(this.callRecords, (record: CallRecord, index: number) => {
                  ListItem() {
                    this.buildCallRecordItem(record)
                  }
                }, (record: CallRecord, index: number) => `${record.accountId}-${record.timestamp}-${index}`)
              }
              .width('100%')
              .layoutWeight(1)
            }
          }
          .width('100%')
          .padding({ left: 16, right: 16, top: 20 })
          .layoutWeight(1)
        }
        .width('100%')
        .layoutWeight(1)
        .backgroundColor('#FFFFFF')

        // åº•éƒ¨å‘èµ·é€šè¯æŒ‰é’®
        Button() {
          Row() {
            Text('ğŸ“')
              .fontSize(20)
              .margin({ right: 8 })

          Text(this.getString($r('app.string.single_call_button')))
            .fontSize(16)
            .fontColor('#FFFFFF')
            .fontWeight(FontWeight.Medium)
        }
        .justifyContent(FlexAlign.Center)
        .alignItems(VerticalAlign.Center)
      }
      .type(ButtonType.Normal)
      .width('80%')
      .height(50)
      .backgroundColor('#007DFF')
      .borderRadius(8)
      .margin({ left: 16, right: 16, top: 16, bottom: 16 })
      .onClick(() => {
        this.call()
      })
    }
    .width('100%')
    .height('100%')
    .backgroundColor('#FFFFFF')
  }

  async call() {
    let accountId = this.targetAccountId.trim();

    // éªŒè¯è¾“å…¥
    if (!accountId) {
      this.getUIContext().showAlertDialog({
        title: $r('app.string.single_call_alert_title'),
        message: $r('app.string.single_call_alert_message'),
        autoCancel: true,
        alignment: DialogAlignment.Bottom,
        confirm: {
          value: $r('app.string.single_call_alert_confirm'),
          action: () => {
            console.info('[SingleCall] ç”¨æˆ·ç‚¹å‡»äº† è¯·è¾“å…¥è¢«å‘¼å«è´¦å·ID æç¤ºçš„ç¡®è®¤æŒ‰é’®')
          }
        }
      });
      return;
    }

    // æ£€æŸ¥æ˜¯å¦å‘¼å«è‡ªå·±
    try {
      const nim = this.getUserModel().getNimSdk();
      const currentUserId: string = nim?.loginService?.getLoginUser?.() ?? '';
      if (currentUserId && currentUserId === accountId) {
        // ä¸èƒ½å‘¼å«è‡ªå·±ï¼Œå¼¹å‡ºå›½é™…åŒ–æç¤º
        this.getUIContext().showAlertDialog({
          title: $r('app.string.single_call_alert_title'),
          message: $r('app.string.single_call_alert_self'),
          autoCancel: true,
          alignment: DialogAlignment.Bottom,
          confirm: {
            value: $r('app.string.single_call_alert_confirm'),
            action: () => {
              console.info('[SingleCall] ç”¨æˆ·å°è¯•å‘¼å«è‡ªå·±ï¼Œå·²æç¤ºä¸èƒ½å‘¼å«è‡ªå·±');
            }
          }
        });
        return;
      }
    } catch (error) {
      console.error('[SingleCall] æ£€æŸ¥æ˜¯å¦å‘¼å«è‡ªå·±æ—¶å‡ºé”™:', error);
      // å‡ºé”™æ—¶ä¸é˜»å¡æ­£å¸¸å‘¼å«æµç¨‹
    }

    this.enableFuLiveBeauty(true)
    
    // å‘èµ·å‘¼å«
    let param = new NECallParam(accountId, this.callType)
    
    // åº”ç”¨è®¾ç½®åˆ°å‘¼å«å‚æ•°ï¼ˆå¦‚ customChannelName, rtcUid, globalCCParamsï¼‰
    this.callSettingsManager.applySettingsToCallParam(param)

    // ä»è®¾ç½®ä¸­åˆ›å»º pushConfig
    const settings = this.callSettingsManager.getSettings();
    if (settings.pushEnabled || settings.pushTitle || settings.pushContent || settings.pushPayload) {
      const pushConfig = new NECallPushConfig();
      pushConfig.pushEnabled = settings.pushEnabled;
      if (settings.pushTitle) {
        pushConfig.pushTitle = settings.pushTitle;
      }
      if (settings.pushContent) {
        pushConfig.pushContent = settings.pushContent;
      }
      if (settings.pushPayload) {
        pushConfig.pushPayload = settings.pushPayload;
      }
      param.pushConfig = pushConfig;
    }

    const result = await NECallUI.getInstance().call(param)

    // å¦‚æœæƒé™è¢«æ‹’ç»ï¼Œå¼¹å‡ºé¡µé¢çº§åˆ«çš„æç¤ºå¯¹è¯æ¡†ï¼ˆåŒºåˆ†éº¦å…‹é£/æ‘„åƒå¤´ï¼‰
    if (result && result.code != NEErrorCode.SUCCESS) {
      // æ ¹æ®é”™è¯¯ç é€‰æ‹©ä¸åŒçš„æ ‡é¢˜å’Œå†…å®¹ï¼ˆæ”¯æŒå›½é™…åŒ–ï¼‰
      let titleRes: Resource;
      let messageRes: Resource;

      if (result.code === NEErrorCode.ERROR_PERMISSION_DENIED_MICROPHONE) {
        titleRes = $r('app.string.permission_mic_title');
        messageRes = $r('app.string.permission_mic_message');
      } else if (result.code === NEErrorCode.ERROR_PERMISSION_DENIED_CAMERA) {
        titleRes = $r('app.string.permission_camera_title');
        messageRes = $r('app.string.permission_camera_message');
      } else {
        // å…¶ä»–é”™è¯¯ï¼Œä½¿ç”¨é€šç”¨æ–‡æ¡ˆ
        titleRes = $r('app.string.permission_common_title');
        messageRes = $r('app.string.permission_common_message');
      }

      // ä½¿ç”¨ UIContext.showAlertDialog(AlertDialogParamWithButtons) å±•ç¤ºä¸¤ä¸ªæŒ‰é’®
      const buttons: LocalAlertDialogButtonOptions[] = [
        {
          // â€œæˆ‘çŸ¥é“äº†â€ æŒ‰é’®ï¼šä»…å…³é—­å¯¹è¯æ¡†
          value: this.getString($r('app.string.permission_button_iknow')),
          action: () => {
            console.info('[SingleCall] ç”¨æˆ·ç‚¹å‡»äº† æˆ‘çŸ¥é“äº†')
          }
        } as LocalAlertDialogButtonOptions,
        {
          // â€œå‰å¾€è®¾ç½®â€ æŒ‰é’®ï¼šè·³è½¬åˆ°åº”ç”¨è®¾ç½®é¡µé¢
          value: this.getString($r('app.string.permission_button_goto_settings')),
          action: () => {
            try {
              const context = getContext(this) as common.UIAbilityContext;
              context.startAbility({
                bundleName: 'com.huawei.hmos.settings',
                abilityName: 'com.huawei.hmos.settings.MainAbility',
                uri: 'application_info_entry'
              }).catch((err: Error) => {
                console.error('[SingleCall] æ‰“å¼€ç³»ç»Ÿè®¾ç½®å¤±è´¥:', err);
              });
            } catch (error) {
              console.error('[SingleCall] æ‰“å¼€ç³»ç»Ÿè®¾ç½®å¼‚å¸¸:', error);
            }
          }
        } as LocalAlertDialogButtonOptions
      ];

      this.getUIContext().showAlertDialog({
        title: titleRes,
        message: messageRes,
        autoCancel: true,
        alignment: DialogAlignment.Center,
        buttons: buttons
      });
      return;
    }

    const callingText = this.getString($r('app.string.single_call_log_calling'));
    const callTypeText = this.callType === NECallType.AUDIO 
      ? this.getString($r('app.string.single_call_log_audio_call'))
      : this.getString($r('app.string.single_call_log_video_call'));
    console.log(`${callingText}: ${accountId}, ${callTypeText}`)
  }

  private enableFuLiveBeauty(enable: boolean) {

    if (this.fuRender == null) {
      this.fuRender = new VideoFuRender()
      this.fuRender.setBundlePath(getContext().filesDir + '/beauty')
      BeautyDataService.sharedInstance().registerFuRender(this.fuRender)
    }

    if (enable) {
      let configMain: NERtcConstants.NERtcVideoEncodeConfiguration = new NERtcConstants.NERtcVideoEncodeConfiguration
      configMain.colorFormat = NERtcConstants.NERtcVideoColorFormat.kNERtcVideoColorFormatI420

      let ret = NERtcSDK.getInstance().setLocalVideoConfig(configMain, NERtcConstants.NERtcVideoStreamType.kNERtcVideoStreamTypeMain)
      if (ret != NERtcConstants.ErrorCode.NO_ERROR) {
      }
      let handle = this.fuRender.getNativeHandle();
      let result = NERtcSDK.getInstance().setExternalVideoProcessPlugin(handle);
      console.info(`Set External video process plugin: ${result}`)
      this.fuRender.enableBeauty(true)

      //set restore value.
      BeautyDataService.sharedInstance().skinViewModel.setAllSkinValues()
      BeautyDataService.sharedInstance().shapeViewModel.setAllShapeValues()
      BeautyDataService.sharedInstance().filterViewModel.setCurrentFilter()
    } else {
      NERtcSDK.getInstance().setExternalVideoProcessPlugin(0n);
      this.fuRender.enableBeauty(false)
    }
  }

  private enableBytedEffectBeauty(enable: boolean) {
    if (this.bytedRender == null) {
      this.bytedRender = new BytedRender()
      const licensePath = "/LicenseBag.bundle/xxxxxx.licbag"
      this.bytedRender.setBundlePath(getContext().filesDir, licensePath)
    }
    if (enable) {
      let configMain: NERtcConstants.NERtcVideoEncodeConfiguration = new NERtcConstants.NERtcVideoEncodeConfiguration
      configMain.colorFormat = NERtcConstants.NERtcVideoColorFormat.kNERtcVideoColorFormatTexture

      let ret = NERtcSDK.getInstance().setLocalVideoConfig(configMain, NERtcConstants.NERtcVideoStreamType.kNERtcVideoStreamTypeMain)
      if (ret != NERtcConstants.ErrorCode.NO_ERROR) {
      }

      let handle = this.bytedRender.getNativeHandle();
      let result = NERtcSDK.getInstance().setExternalVideoProcessPlugin(handle);
      console.info(`SetExternalProcessPlugin result: ${result}`)
      this.bytedRender.enableBeauty(true)
    } else {
      NERtcSDK.getInstance().setExternalVideoProcessPlugin(0n);
      this.bytedRender.enableBeauty(false)
    }
  }

  /**
   * åº”ç”¨è®¾ç½®
   */
  private applySettings(): void {
    const settings = this.callSettingsManager.getSettings();
    
    // è®¾ç½®è¶…æ—¶æ—¶é—´
    if (settings.timeout) {
      try {
        const timeoutSeconds = parseInt(settings.timeout, 10);
        if (!isNaN(timeoutSeconds) && timeoutSeconds > 0) {
          const result = NECallEngine.getInstance().setTimeout(timeoutSeconds);
          console.info(`[SingleCall] Applied timeout: ${timeoutSeconds}s, result: ${result}`);
        } else {
          console.warn(`[SingleCall] Invalid timeout value: ${settings.timeout}`);
        }
      } catch (error) {
        console.error(`[SingleCall] Failed to apply timeout: ${settings.timeout}`, error);
      }
    }
    
    // è®¾ç½®è‡ªå®šä¹‰ RTC UID
    if (settings.customRtcUid) {
      try {
        const customRtcUid = BigInt(settings.customRtcUid);
        const selfInfo = new NESelfInfo();
        selfInfo.customRtcUid = customRtcUid;
        NECallEngine.getInstance().setSelfInfo(selfInfo).then((result) => {
          if (result.code === 0) {
            console.info(`[SingleCall] Applied customRtcUid: ${settings.customRtcUid}`);
          } else {
            console.error(`[SingleCall] Failed to apply customRtcUid: ${result.message}`);
          }
        });
      } catch (error) {
        console.error(`[SingleCall] Failed to parse customRtcUid: ${settings.customRtcUid}`, error);
      }
    }

    // è®¾ç½®è¯å•æä¾›è€…
    try {
      if (settings.enableRecordProvider) {
        // å¯ç”¨è‡ªå®šä¹‰è¯å•
        if (!this.testRecordProvider) {
          this.testRecordProvider = new TestRecordProvider();
        }
        NECallEngine.getInstance().setCallRecordProvider(this.testRecordProvider);
        console.info(`[SingleCall] Applied recordProvider: enabled`);
      } else {
        // ç¦ç”¨è‡ªå®šä¹‰è¯å•ï¼ˆè®¾ç½®ä¸º nullï¼Œä½¿ç”¨é»˜è®¤è¯å•å‘é€ï¼‰
        NECallEngine.getInstance().setCallRecordProvider(null);
        console.info(`[SingleCall] Applied recordProvider: disabled (use default)`);
      }
    } catch (error) {
      console.error(`[SingleCall] Failed to apply recordProvider:`, error);
    }

    // è®¾ç½®è™šåŒ–åŠŸèƒ½
    try {
      // è®¾ç½® CallState ä¸­çš„ enableBlurBackground
      CallState.instance.enableBlurBackground = settings.enableBlur;
      console.info(`[SingleCall] Applied enableBlur: ${settings.enableBlur}, enableBlurBackground: ${CallState.instance.enableBlurBackground}`);
      
      // å¦‚æœå¯ç”¨è™šåŒ–ï¼Œè°ƒç”¨ enableVirtualBackground
      if (settings.enableBlur) {
        CallManager.instance.enableVirtualBackground(true);
        console.info(`[SingleCall] Applied enableVirtualBackground: true`);
      } else {
        CallManager.instance.enableVirtualBackground(false);
        console.info(`[SingleCall] Applied enableVirtualBackground: false`);
      }
    } catch (error) {
      console.error(`[SingleCall] Failed to apply enableBlur:`, error);
    }
  }

  /**
   * åˆå§‹åŒ–é€šè¯è®°å½•æœåŠ¡
   */
  private async initCallRecordService(context: common.Context): Promise<void> {
    try {
      console.info('[SingleCall] Initializing call record service...');
      this.callRecordService = CallRecordServiceImpl.getInstance(context);
      const storage = CallRecordStorage.getInstance();
      await storage.ensureInitialized(context);
      console.info('[SingleCall] Call record service initialized');
    } catch (error) {
      console.error(`[SingleCall] Failed to init call record service: ${error}`);
    }
  }

  /**
   * åŠ è½½é€šè¯è®°å½•
   */
  private async loadCallRecords(): Promise<void> {
    try {
      if (!this.callRecordService) {
        console.warn('[SingleCall] Call record service not initialized');
        return;
      }
      console.info('[SingleCall] Loading call records...');
      // const accountId = await this.callRecordService.getCurrentAccountId();
      const accountId = this.getUserModel().getNimSdk().loginService.getLoginUser();
      console.info(`[SingleCall] Current account ID: ${accountId}`);
      const records = await this.callRecordService.loadCurrentAccountRecords();
      console.info(`[SingleCall] Loaded ${records.length} call records`);
      this.callRecords = records;
      console.info(`[SingleCall] UI updated with ${this.callRecords.length} records`);
    } catch (error) {
      console.error(`[SingleCall] Failed to load call records: ${error}`);
    }
  }

  /**
   * æ·»åŠ é€šè¯è®°å½•
   */
  private async addCallRecord(record: CallRecord): Promise<void> {
    try {
      if (!this.callRecordService) {
        console.warn('[SingleCall] Call record service not initialized, cannot add record');
        return;
      }
      console.info(`[SingleCall] Adding call record: accountId=${record.accountId}, isIncoming=${record.isIncoming}, callType=${record.callType}`);
      // å…ˆæ›´æ–°UI
      this.callRecords.unshift(record);
      console.info(`[SingleCall] UI updated, current records count: ${this.callRecords.length}`);
      // é™åˆ¶è®°å½•æ•°é‡
      if (this.callRecords.length > 100) {
        const removedCount = this.callRecords.length - 100;
        this.callRecords.splice(100);
        console.info(`[SingleCall] Removed ${removedCount} old records from UI`);
      }
      // ä¿å­˜åˆ°å­˜å‚¨
      const result = await this.callRecordService.addRecordToCurrentAccount(record);
      console.info(`[SingleCall] Save result: ${result}`);
    } catch (error) {
      console.error(`[SingleCall] Failed to add call record: ${error}`);
    }
  }

  /**
   * æ¸…é™¤é€šè¯è®°å½•
   */
  private async clearCallRecords(): Promise<void> {
    try {
      if (!this.callRecordService) {
        return;
      }
      this.callRecords = [];
      await this.callRecordService.clearCurrentAccountRecords();
    } catch (error) {
      console.error(`[SingleCall] Failed to clear call records: ${error}`);
    }
  }

  /**
   * æ³¨å†Œæ¶ˆæ¯ç›‘å¬
   */
  private registerMessageListeners(): void {
    try {
      const context = getContext(this) as common.UIAbilityContext;
      const nimSdk = this.getUserModel().getNimSdk();
      const messageService: V2NIMMessageService | undefined = nimSdk.messageService;

      if (!messageService) {
        console.warn('[SingleCall] Message service not available');
        return;
      }

      // ç›‘å¬æ¥æ”¶æ¶ˆæ¯
      this.receiveMessageHandler = (messages: V2NIMMessage[]) => {
        console.info(`[SingleCall] onReceiveMessages: received ${messages.length} messages`);
        const nimSdk = this.getUserModel().getNimSdk();
        for (const message of messages) {
          console.info(`[SingleCall] Processing message: messageType=${message.messageType}, messageClientId=${message.messageClientId}`);
          RecordUtils.parseForCallRecord(message, nimSdk).then((record: CallRecord | null) => {
            if (record) {
              console.info(`[SingleCall] Parsed call record from received message: accountId=${record.accountId}`);
              this.addCallRecord(record);
            } else {
              console.info(`[SingleCall] No call record parsed from received message`);
            }
          });
        }
      };

      // ç›‘å¬å‘é€æ¶ˆæ¯
      this.sendMessageHandler = (message: V2NIMMessage) => {
        console.info(`[SingleCall] onSendMessage: messageType=${message.messageType}, messageClientId=${message.messageClientId}`);
        const nimSdk = this.getUserModel().getNimSdk();
        RecordUtils.parseForCallRecord(message, nimSdk).then((record: CallRecord | null) => {
          if (record) {
            console.info(`[SingleCall] Parsed call record from sent message: accountId=${record.accountId}`);
            this.addCallRecord(record);
          } else {
            console.info(`[SingleCall] No call record parsed from sent message`);
          }
        });
      };

      messageService.on('onReceiveMessages', this.receiveMessageHandler);
      messageService.on('onSendMessage', this.sendMessageHandler);

      console.info('[SingleCall] Message listeners registered');
    } catch (error) {
      console.error(`[SingleCall] Failed to register message listeners: ${error}`);
    }
  }

  /**
   * å–æ¶ˆæ¶ˆæ¯ç›‘å¬
   */
  private unregisterMessageListeners(): void {
    try {
      const context = getContext(this) as common.UIAbilityContext;
      const nimSdk = this.getUserModel().getNimSdk();
      const messageService: V2NIMMessageService | undefined = nimSdk.messageService;

      if (!messageService) {
        return;
      }

      if (this.receiveMessageHandler) {
        messageService.off('onReceiveMessages', this.receiveMessageHandler);
        this.receiveMessageHandler = null;
      }

      if (this.sendMessageHandler) {
        messageService.off('onSendMessage', this.sendMessageHandler);
        this.sendMessageHandler = null;
      }

      console.info('[SingleCall] Message listeners unregistered');
    } catch (error) {
      console.error(`[SingleCall] Failed to unregister message listeners: ${error}`);
    }
  }

  /**
   * æ„å»ºé€šè¯è®°å½•é¡¹
   */
  @Builder
  buildCallRecordItem(record: CallRecord) {
    Row() {
      // å‘¼å…¥/å‘¼å‡ºå›¾æ ‡ - æ ¹æ®çŠ¶æ€å’Œæ–¹å‘å†³å®šé¢œè‰²
      Text(record.isIncoming ? 'â†“' : 'â†‘')
        .fontSize(20)
        .fontColor(record.status === 1 ? (record.isIncoming ? '#34C759' : '#007DFF') : '#FF3B30')
        .width(24)
        .height(24)
        .textAlign(TextAlign.Center)

      // å¯¹æ–¹accountId - æ ¹æ®çŠ¶æ€å†³å®šé¢œè‰²
      Text(record.accountId)
        .fontSize(16)
        .fontColor(record.status === 1 ? '#182431' : '#FF3B30')
        .fontWeight(FontWeight.Medium)
        .layoutWeight(1)
        .margin({ left: 12 })
        .maxLines(1)
        .textOverflow({ overflow: TextOverflow.Ellipsis })

      // é€šè¯æ—¶é•¿ï¼ˆä»…å½“é€šè¯å®Œæˆæ—¶æ˜¾ç¤ºï¼‰
      if (record.status === 1 && record.duration > 0) {
        Text(this.formatDuration(record.duration))
          .fontSize(14)
          .fontColor('#8E8E93')
          .margin({ right: 8 })
      }

      // æ—¶é—´
      Text(this.formatTimestamp(record.timestamp))
        .fontSize(14)
        .fontColor('#8E8E93')
        .margin({ right: 8 })

      // é€šè¯ç±»å‹å›¾æ ‡
      Text(record.callType === NECallType.VIDEO ? 'ğŸ“¹' : 'ğŸ“')
        .fontSize(16)
    }
    .width('100%')
    .height(56)
    .padding({ left: 12, right: 12 })
    .backgroundColor('#F5F5F5')
    .borderRadius(8)
    .margin({ bottom: 8 })
    .onClick(() => {
      this.callFromRecord(record);
    })
  }

  /**
   * æ ¼å¼åŒ–æ—¶é—´æˆ³
   */
  private formatTimestamp(timestamp: number): string {
    const now = Date.now();
    const today = new Date(now);
    today.setHours(0, 0, 0, 0);
    const recordDate = new Date(timestamp);
    recordDate.setHours(0, 0, 0, 0);

    if (recordDate.getTime() === today.getTime()) {
      // ä»Šå¤©æ˜¾ç¤ºæ—¶é—´
      const date = new Date(timestamp);
      const hours = date.getHours().toString().padStart(2, '0');
      const minutes = date.getMinutes().toString().padStart(2, '0');
      const seconds = date.getSeconds().toString().padStart(2, '0');
      return `${hours}:${minutes}:${seconds}`;
    } else {
      // å…¶ä»–æ—¥æœŸæ˜¾ç¤ºå®Œæ•´æ—¥æœŸå’Œæ—¶é—´
      const date = new Date(timestamp);
      const month = date.getMonth() + 1;
      const day = date.getDate();
      const hours = date.getHours().toString().padStart(2, '0');
      const minutes = date.getMinutes().toString().padStart(2, '0');
      return `${month}æœˆ${day}æ—¥ ${hours}:${minutes}`;
    }
  }

  /**
   * æ ¼å¼åŒ–é€šè¯æ—¶é•¿ï¼ˆç§’è½¬æ¢ä¸º mm:ss æˆ– hh:mm:ss æ ¼å¼ï¼‰
   */
  private formatDuration(seconds: number): string {
    if (seconds <= 0) {
      return '00:00';
    }
    
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;
    
    if (hours > 0) {
      return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    } else {
      return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }
  }

  /**
   * ä»è®°å½•å‘èµ·é€šè¯
   */
  private callFromRecord(record: CallRecord): void {
    // è®¾ç½®è¢«å«ç”¨æˆ·ID
    this.targetAccountId = record.accountId;
    // è®¾ç½®é€šè¯ç±»å‹
    this.callType = record.callType;
    // å‘èµ·é€šè¯
    this.call();
  }

}
