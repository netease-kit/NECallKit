// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.0.3 effective-5.10 (swiftlang-6.0.3.1.10 clang-1600.0.30.1)
// swift-module-flags: -target arm64-apple-ios13.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -enable-bare-slash-regex -module-name NECommonUIKit
// swift-module-flags-ignorable: -no-verify-emitted-module-interface
import AVFoundation
import Combine
import Compression
import CoreFoundation
import CoreGraphics
import CoreText
import DeveloperToolsSupport
import Foundation
import MobileCoreServices
import NECommonKit
@_exported import NECommonUIKit
import ObjectiveC
import Photos
import PhotosUI
import QuartzCore
import SDWebImage
import Swift
import SwiftUI
import UIKit
import WebKit
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
import zlib
@objc public protocol BrowserToolsBarDelegate : ObjectiveC.NSObjectProtocol {
  @objc func didCloseClick()
  @objc func didSaveClick()
}
@objc @_inheritsConvenienceInitializers @objcMembers @_Concurrency.MainActor @preconcurrency open class BrowserToolsBar : UIKit.UIView {
  @objc @_Concurrency.MainActor @preconcurrency weak public var delegate: (any NECommonUIKit.BrowserToolsBarDelegate)?
  @objc @_Concurrency.MainActor @preconcurrency public var saveButton: NECommonUIKit.ExpandButton {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency public var closeButton: NECommonUIKit.ExpandButton {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc @_Concurrency.MainActor @preconcurrency open func setupUI()
  @objc @_Concurrency.MainActor @preconcurrency open func saveClick()
  @objc @_Concurrency.MainActor @preconcurrency open func closeClick()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objcMembers public class CommonUIConfig : ObjectiveC.NSObject {
  @objc public static let shared: NECommonUIKit.CommonUIConfig
  @objc public var backArrowImage: UIKit.UIImage?
  @objc deinit
}
public let coreLoader: NECommonKit.CommonLoader<NECommonUIKit.TabNavigationView>
public func commonLocalizable(_ key: Swift.String) -> Swift.String
public let useSystemNav: Swift.String
@objc @_inheritsConvenienceInitializers @objcMembers @_Concurrency.MainActor @preconcurrency open class CopyableLabel : NECommonUIKit.NELinkableLabel {
  @objc @_Concurrency.MainActor @preconcurrency public var copyString: Swift.String?
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public var canBecomeFirstResponder: Swift.Bool {
    @objc get
  }
  @_Concurrency.MainActor @preconcurrency @objc dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func copy(_ sender: Any?)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func canPerformAction(_ action: ObjectiveC.Selector, withSender sender: Any?) -> Swift.Bool
  @objc deinit
}
public struct CornerType : Swift.OptionSet {
  public init(rawValue: Swift.Int)
  public let rawValue: Swift.Int
  public static let none: NECommonUIKit.CornerType
  public static let topLeft: NECommonUIKit.CornerType
  public static let topRight: NECommonUIKit.CornerType
  public static let bottomLeft: NECommonUIKit.CornerType
  public static let bottomRight: NECommonUIKit.CornerType
  public typealias ArrayLiteralElement = NECommonUIKit.CornerType
  public typealias Element = NECommonUIKit.CornerType
  public typealias RawValue = Swift.Int
}
@objc @_inheritsConvenienceInitializers @objcMembers @_Concurrency.MainActor @preconcurrency open class CornerCell : UIKit.UITableViewCell {
  @objc @_Concurrency.MainActor @preconcurrency public var cornerLayer: QuartzCore.CAShapeLayer
  @objc @_Concurrency.MainActor @preconcurrency public var fillColor: UIKit.UIColor
  @objc @_Concurrency.MainActor @preconcurrency public var edgeInset: UIKit.UIEdgeInsets
  @objc @_Concurrency.MainActor @preconcurrency public var dividerLineLeftMargin: UIKit.NSLayoutConstraint?
  @objc @_Concurrency.MainActor @preconcurrency public var dividerLineRightMargin: UIKit.NSLayoutConstraint?
  @_Concurrency.MainActor @preconcurrency public var cornerType: NECommonUIKit.CornerType {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(style: UIKit.UITableViewCell.CellStyle, reuseIdentifier: Swift.String?)
  @objc @_Concurrency.MainActor @preconcurrency public var dividerLine: UIKit.UIView {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency public var showDefaultLine: Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func draw(_ rect: CoreFoundation.CGRect)
  @objc @_Concurrency.MainActor @preconcurrency open func drawRoundedCorner(rect: CoreFoundation.CGRect)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @objcMembers @_Concurrency.MainActor @preconcurrency open class ExpandButton : UIKit.UIButton {
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func point(inside point: CoreFoundation.CGPoint, with event: UIKit.UIEvent?) -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@objc public enum FileState : Swift.Int {
  case FileOpen = 1
  case FileDownload
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc @_inheritsConvenienceInitializers @objcMembers @_Concurrency.MainActor @preconcurrency open class FileStateView : UIKit.UIView {
  @objc @_Concurrency.MainActor @preconcurrency public var circleLayer: QuartzCore.CAShapeLayer {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency public var progressLayer: QuartzCore.CAShapeLayer {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency public var state: NECommonUIKit.FileState {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency public var FileOpenImage: UIKit.UIImageView {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency public var alphaBackView: UIKit.UIView {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency public var verticalLineLeft: UIKit.UIView {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency public var verticalLineRight: UIKit.UIView {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc @_Concurrency.MainActor @preconcurrency open func setProgress(_ progress: Swift.Float)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @objcMembers @_Concurrency.MainActor @preconcurrency open class SearchSessionBaseView : UIKit.UITableViewHeaderFooterView {
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(reuseIdentifier: Swift.String?)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc @_Concurrency.MainActor @preconcurrency open func setupUI()
  @objc @_Concurrency.MainActor @preconcurrency open func setUpTitle(title: Swift.String)
  @objc @_Concurrency.MainActor @preconcurrency public var titleLabel: UIKit.UILabel {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency public var bottomLine: UIKit.UIView {
    @objc get
    @objc set
  }
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @objcMembers @_Concurrency.MainActor @preconcurrency open class FunSearchSessionHeaderView : NECommonUIKit.SearchSessionBaseView {
  @_Concurrency.MainActor @preconcurrency @objc override open func setupUI()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(reuseIdentifier: Swift.String?)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency public class FunSearchView : UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency public var backView: UIKit.UIView {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var searchButton: UIKit.UIButton {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public init(searchButtonLeftConstant: CoreFoundation.CGFloat = 0, searchButtonRightConstant: CoreFoundation.CGFloat = 0)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency open func updateSearchButtonConstant(searchButtonLeftConstant: CoreFoundation.CGFloat? = nil, searchButtonRightConstant: CoreFoundation.CGFloat? = nil)
  @objc deinit
}
@objc @_Concurrency.MainActor @preconcurrency public class NEActionSheetController : UIKit.UINavigationController {
  @_Concurrency.MainActor @preconcurrency public var dismissOnTouchOutside: Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(rootViewController: UIKit.UIViewController)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func viewDidLayoutSubviews()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func forwardingTarget(for aSelector: ObjectiveC.Selector!) -> Any?
  @objc deinit
}
@_hasMissingDesignatedInitializers @objcMembers public class NEAlertViewController {
  @objc public class func presentAlertViewController(_ title: Swift.String?, messageContent: Swift.String?, cancelTitle: Swift.String?, confirmTitle: Swift.String?, cancelComplete: (() -> Swift.Void)? = nil, confirmComplete: (() -> Swift.Void)? = nil)
  @objc public class func removePresentAlertViewController()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @objcMembers @_Concurrency.MainActor @preconcurrency open class NEAnimatedButton : NECommonUIKit.NEAnimatedControl {
  @_Concurrency.MainActor @preconcurrency override public init(animation: NECommonUIKit.NELottieAnimation?, configuration: NECommonUIKit.NELottieConfiguration = .shared)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init()
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func beginTracking(_ touch: UIKit.UITouch, with event: UIKit.UIEvent?) -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func endTracking(_ touch: UIKit.UITouch?, with event: UIKit.UIEvent?)
  @objc @_Concurrency.MainActor @preconcurrency public var performAction: (() -> Swift.Void)?
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public var accessibilityTraits: UIKit.UIAccessibilityTraits {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency public func setPlayRange(fromProgress: NECommonUIKit.NEAnimationProgressTime, toProgress: NECommonUIKit.NEAnimationProgressTime, event: NECommonUIKit.NELottieControlEvent)
  @objc @_Concurrency.MainActor @preconcurrency public func setPlayRange(fromMarker fromName: Swift.String, toMarker toName: Swift.String, event: NECommonUIKit.NELottieControlEvent)
  @objc deinit
}
@objc @objcMembers @_Concurrency.MainActor @preconcurrency open class NEAnimatedControl : NECommonUIKit.NELottieControlType {
  @_Concurrency.MainActor @preconcurrency public init(animation: NECommonUIKit.NELottieAnimation?, configuration: NECommonUIKit.NELottieConfiguration = .shared)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public init()
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var isEnabled: Swift.Bool {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var isSelected: Swift.Bool {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var isHighlighted: Swift.Bool {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func beginTracking(_ touch: UIKit.UITouch, with event: UIKit.UIEvent?) -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func continueTracking(_ touch: UIKit.UITouch, with event: UIKit.UIEvent?) -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func endTracking(_ touch: UIKit.UITouch?, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func cancelTracking(with event: UIKit.UIEvent?)
  @objc @_Concurrency.MainActor @preconcurrency open func animationDidSet()
  @objc @_Concurrency.MainActor @preconcurrency final public let animationView: NECommonUIKit.NELottieAnimationView
  @_Concurrency.MainActor @preconcurrency public var animation: NECommonUIKit.NELottieAnimation? {
    get
    set
  }
  @objc @_Concurrency.MainActor @preconcurrency public var animationSpeed: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency public func setLayer(named: Swift.String, forState: NECommonUIKit.NELottieControlState)
  @_Concurrency.MainActor @preconcurrency public func setValueProvider(_ valueProvider: any NECommonUIKit.NEAnyValueProvider, keypath: NECommonUIKit.NEAnimationKeypath)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency open class NEAnimatedSwitch : NECommonUIKit.NEAnimatedControl {
  @_Concurrency.MainActor @preconcurrency override public init(animation: NECommonUIKit.NELottieAnimation?, configuration: NECommonUIKit.NELottieConfiguration = .shared)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init()
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency @objc override open func animationDidSet()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func endTracking(_ touch: UIKit.UITouch?, with event: UIKit.UIEvent?)
  public enum NECancelBehavior {
    case reverse
    case none
    public static func == (a: NECommonUIKit.NEAnimatedSwitch.NECancelBehavior, b: NECommonUIKit.NEAnimatedSwitch.NECancelBehavior) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_Concurrency.MainActor @preconcurrency public var cancelBehavior: NECommonUIKit.NEAnimatedSwitch.NECancelBehavior
  @objc @_Concurrency.MainActor @preconcurrency public var animateUpdateWhenChangingAnimation: Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public var accessibilityTraits: UIKit.UIAccessibilityTraits {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency public var stateUpdated: ((_ isOn: Swift.Bool) -> Swift.Void)?
  @objc @_Concurrency.MainActor @preconcurrency public var isOn: Swift.Bool {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency public func setIsOn(_ isOn: Swift.Bool, animated: Swift.Bool, shouldFireHaptics: Swift.Bool = true)
  @objc @_Concurrency.MainActor @preconcurrency public func setProgressForState(fromProgress: NECommonUIKit.NEAnimationProgressTime, toProgress: NECommonUIKit.NEAnimationProgressTime, forOnState: Swift.Bool)
  @objc deinit
}
public protocol NEAnimationCacheProvider : AnyObject, Swift.Sendable {
  func animation(forKey: Swift.String) -> NECommonUIKit.NELottieAnimation?
  func setAnimation(_ animation: NECommonUIKit.NELottieAnimation, forKey: Swift.String)
  func clearCache()
}
public typealias NELottieCompletionBlock = (_ completed: Swift.Bool) -> Swift.Void
public protocol NEAnimationFontProvider {
  func fontFor(family: Swift.String, size: CoreFoundation.CGFloat) -> CoreText.CTFont?
}
final public class NEDefaultFontProvider : NECommonUIKit.NEAnimationFontProvider {
  public init()
  final public func fontFor(family: Swift.String, size: CoreFoundation.CGFloat) -> CoreText.CTFont?
  @objc deinit
}
extension NECommonUIKit.NEDefaultFontProvider : Swift.Equatable {
  public static func == (_: NECommonUIKit.NEDefaultFontProvider, _: NECommonUIKit.NEDefaultFontProvider) -> Swift.Bool
}
public protocol NEAnimationImageProvider {
  var cacheEligible: Swift.Bool { get }
  func imageForAsset(asset: NECommonUIKit.NEImageAsset) -> CoreGraphics.CGImage?
  func contentsGravity(for asset: NECommonUIKit.NEImageAsset) -> QuartzCore.CALayerContentsGravity
}
extension NECommonUIKit.NEAnimationImageProvider {
  public var cacheEligible: Swift.Bool {
    get
  }
  public func contentsGravity(for _: NECommonUIKit.NEImageAsset) -> QuartzCore.CALayerContentsGravity
}
public struct NEAnimationKeypath : Swift.Hashable, Swift.ExpressibleByStringLiteral {
  public init(keypath: Swift.String)
  public init(stringLiteral: Swift.String)
  public init(keys: [Swift.String])
  public var keys: [Swift.String] {
    get
  }
  public var string: Swift.String {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: NECommonUIKit.NEAnimationKeypath, b: NECommonUIKit.NEAnimationKeypath) -> Swift.Bool
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
  public var hashValue: Swift.Int {
    get
  }
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency final public class NEAnimationSubview : UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
public protocol NEAnimationKeypathTextProvider : AnyObject {
  func text(for keypath: NECommonUIKit.NEAnimationKeypath, sourceText: Swift.String) -> Swift.String?
}
@available(*, deprecated, message: "`NEAnimationKeypathTextProvider` has been deprecated and renamed to `NELegacyAnimationTextProvider`. Instead, conform to `NEAnimationKeypathTextProvider` instead or conform to `NELegacyAnimationTextProvider` explicitly.")
public typealias NEAnimationTextProvider = NECommonUIKit.NELegacyAnimationTextProvider
public protocol NELegacyAnimationTextProvider : NECommonUIKit.NEAnimationKeypathTextProvider {
  func textFor(keypathName: Swift.String, sourceText: Swift.String) -> Swift.String
}
extension NECommonUIKit.NELegacyAnimationTextProvider {
  public func text(for _: NECommonUIKit.NEAnimationKeypath, sourceText _: Swift.String) -> Swift.String?
}
final public class NEDictionaryTextProvider : NECommonUIKit.NEAnimationKeypathTextProvider, NECommonUIKit.NELegacyAnimationTextProvider {
  public init(_ values: [Swift.String : Swift.String])
  final public func text(for keypath: NECommonUIKit.NEAnimationKeypath, sourceText: Swift.String) -> Swift.String?
  final public func textFor(keypathName: Swift.String, sourceText: Swift.String) -> Swift.String
  @objc deinit
}
extension NECommonUIKit.NEDictionaryTextProvider : Swift.Equatable {
  public static func == (lhs: NECommonUIKit.NEDictionaryTextProvider, rhs: NECommonUIKit.NEDictionaryTextProvider) -> Swift.Bool
}
final public class NEDefaultTextProvider : NECommonUIKit.NEAnimationKeypathTextProvider, NECommonUIKit.NELegacyAnimationTextProvider {
  public init()
  final public func textFor(keypathName _: Swift.String, sourceText: Swift.String) -> Swift.String
  final public func text(for _: NECommonUIKit.NEAnimationKeypath, sourceText: Swift.String) -> Swift.String
  @objc deinit
}
extension NECommonUIKit.NEDefaultTextProvider : Swift.Equatable {
  public static func == (_: NECommonUIKit.NEDefaultTextProvider, _: NECommonUIKit.NEDefaultTextProvider) -> Swift.Bool
}
public typealias NEAnimationFrameTime = CoreFoundation.CGFloat
public typealias NEAnimationProgressTime = CoreFoundation.CGFloat
public protocol NEAnyValueProvider {
  var valueType: any Any.Type { get }
  var typeErasedStorage: NECommonUIKit.NEAnyValueProviderStorage { get }
  func hasUpdate(frame: NECommonUIKit.NEAnimationFrameTime) -> Swift.Bool
}
extension NECommonUIKit.NEAnyValueProvider {
  public func value(frame: NECommonUIKit.NEAnimationFrameTime) -> Any
}
public enum NEValueProviderStorage<T> where T : NECommonUIKit.NEAnyInterpolatable {
  case singleValue(T)
  case keyframes([NECommonUIKit.NEKeyframe<T>])
  case closure((NECommonUIKit.NEAnimationFrameTime) -> T)
}
public enum NEAnyValueProviderStorage {
  case singleValue(Any)
  case keyframes([NECommonUIKit.NEKeyframe<Any>], interpolate: (NECommonUIKit.NEAnimationFrameTime) -> Any)
  case closure((NECommonUIKit.NEAnimationFrameTime) -> Any)
}
@_hasMissingDesignatedInitializers public class NEAsset : Swift.Codable {
  required public init(from decoder: any Swift.Decoder) throws
  final public let id: Swift.String
  @objc deinit
  public func encode(to encoder: any Swift.Encoder) throws
}
extension NECommonUIKit.NEAsset : @unchecked Swift.Sendable {
}
@_inheritsConvenienceInitializers @available(iOSApplicationExtension, unavailable)
@objc @_Concurrency.MainActor @preconcurrency open class NEBarButtonItem : UIKit.UIBarButtonItem {
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init()
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var tintColor: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency open func setTarget(_ target: Swift.AnyObject?, action: ObjectiveC.Selector?)
  @objc @_Concurrency.MainActor @preconcurrency open var invocation: NECommonUIKit.NEInvocation?
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @objcMembers @_Concurrency.MainActor @preconcurrency open class NEBaseTableViewController : NECommonUIKit.NEBaseViewController {
  @objc @_Concurrency.MainActor @preconcurrency public var tableView: UIKit.UITableView {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func viewDidLoad()
  @objc @_Concurrency.MainActor @preconcurrency open func setupTable()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @objcMembers @_Concurrency.MainActor @preconcurrency open class NEBaseViewController : UIKit.UIViewController, UIKit.UIGestureRecognizerDelegate {
  @objc @_Concurrency.MainActor @preconcurrency public var topConstant: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency public var navigationViewHeightAnchor: UIKit.NSLayoutConstraint?
  @objc @_Concurrency.MainActor @preconcurrency final public let navigationView: NECommonUIKit.NENavigationView
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var title: Swift.String? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func viewWillAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func viewDidLoad()
  @objc @_Concurrency.MainActor @preconcurrency open func backEvent()
  @objc @_Concurrency.MainActor @preconcurrency open func toSetting()
  @objc @_Concurrency.MainActor @preconcurrency open func addLeftSwipeDismissGesture()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @objcMembers @_Concurrency.MainActor @preconcurrency open class NEBrokenNetworkView : UIKit.UIView {
  @objc @_Concurrency.MainActor @preconcurrency public var errorIconView: UIKit.UIImageView {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency public var contentLabel: UIKit.UILabel {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
public class NEBundleImageProvider : NECommonUIKit.NEAnimationImageProvider {
  public init(bundle: Foundation.Bundle, searchPath: Swift.String?, contentsGravity: QuartzCore.CALayerContentsGravity = .resize)
  public func imageForAsset(asset: NECommonUIKit.NEImageAsset) -> CoreGraphics.CGImage?
  public func contentsGravity(for _: NECommonUIKit.NEImageAsset) -> QuartzCore.CALayerContentsGravity
  @objc deinit
}
extension NECommonUIKit.NEBundleImageProvider : Swift.Equatable {
  public static func == (lhs: NECommonUIKit.NEBundleImageProvider, rhs: NECommonUIKit.NEBundleImageProvider) -> Swift.Bool
}
public enum ButtonStyle {
  case top
  case left
  case bottom
  case right
  public static func == (a: NECommonUIKit.ButtonStyle, b: NECommonUIKit.ButtonStyle) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension UIKit.UIButton {
  @_Concurrency.MainActor @preconcurrency public func layoutButtonImage(style: NECommonUIKit.ButtonStyle = ButtonStyle.left, space: CoreFoundation.CGFloat = 5)
}
extension NECommonUIKit.NELottieColor : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
final public class NEColorValueProvider {
  public init(block: @escaping NECommonUIKit.NEColorValueProvider.ColorValueBlock)
  public init(_ color: NECommonUIKit.NELottieColor)
  public init(_ keyframes: [NECommonUIKit.NEKeyframe<NECommonUIKit.NELottieColor>])
  public typealias ColorValueBlock = (CoreFoundation.CGFloat) -> NECommonUIKit.NELottieColor
  final public var color: NECommonUIKit.NELottieColor {
    get
    set
  }
  final public var valueType: any Any.Type {
    get
  }
  final public var storage: NECommonUIKit.NEValueProviderStorage<NECommonUIKit.NELottieColor> {
    get
  }
  final public func hasUpdate(frame _: CoreFoundation.CGFloat) -> Swift.Bool
  @objc deinit
}
extension NECommonUIKit.NEColorValueProvider : Swift.Equatable {
  public static func == (lhs: NECommonUIKit.NEColorValueProvider, rhs: NECommonUIKit.NEColorValueProvider) -> Swift.Bool
}
@objc final public class NECompatibleAnimationKeypath : ObjectiveC.NSObject {
  @objc public init(keypath: Swift.String)
  @objc public init(keys: [Swift.String])
  final public let animationKeypath: NECommonUIKit.NEAnimationKeypath
  @objc deinit
}
@objc final public class NECompatibleAnimation : ObjectiveC.NSObject {
  @objc public init(name: Swift.String, subdirectory: Swift.String? = nil, bundle: Foundation.Bundle = Bundle.main)
  @objc deinit
}
@objc public enum NECompatibleRenderingEngineOption : Swift.Int {
  case shared
  case defaultEngine
  case automatic
  case mainThread
  case coreAnimation
  public static func generateLottieConfiguration(_ configuration: NECommonUIKit.NECompatibleRenderingEngineOption) -> NECommonUIKit.NELottieConfiguration
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum NECompatibleBackgroundBehavior : Swift.Int {
  case stop
  case pause
  case pauseAndRestore
  case forceFinish
  case continuePlaying
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc @_Concurrency.MainActor @preconcurrency final public class NECompatibleAnimationView : UIKit.UIView {
  @objc @_Concurrency.MainActor @preconcurrency convenience public init(compatibleAnimation: NECommonUIKit.NECompatibleAnimation)
  @objc @_Concurrency.MainActor @preconcurrency public init(compatibleAnimation: NECommonUIKit.NECompatibleAnimation, compatibleRenderingEngineOption: NECommonUIKit.NECompatibleRenderingEngineOption)
  @objc @_Concurrency.MainActor @preconcurrency convenience public init(url: Foundation.URL)
  @objc @_Concurrency.MainActor @preconcurrency public init(url: Foundation.URL, compatibleRenderingEngineOption: NECommonUIKit.NECompatibleRenderingEngineOption)
  @objc @_Concurrency.MainActor @preconcurrency convenience public init(data: Foundation.Data)
  @objc @_Concurrency.MainActor @preconcurrency public init(data: Foundation.Data, compatibleRenderingEngineOption: NECommonUIKit.NECompatibleRenderingEngineOption)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @objc @_Concurrency.MainActor @preconcurrency final public var compatibleAnimation: NECommonUIKit.NECompatibleAnimation? {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var loopAnimationCount: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var compatibleDictionaryTextProvider: NECommonUIKit.NECompatibleDictionaryTextProvider? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override final public var contentMode: UIKit.UIView.ContentMode {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var shouldRasterizeWhenIdle: Swift.Bool {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var currentProgress: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var duration: CoreFoundation.CGFloat {
    @objc get
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var currentTime: Foundation.TimeInterval {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var currentFrame: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var realtimeAnimationFrame: CoreFoundation.CGFloat {
    @objc get
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var realtimeAnimationProgress: CoreFoundation.CGFloat {
    @objc get
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var animationSpeed: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var respectAnimationFrameRate: Swift.Bool {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var isAnimationPlaying: Swift.Bool {
    @objc get
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var backgroundMode: NECommonUIKit.NECompatibleBackgroundBehavior {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public func play()
  @objc @_Concurrency.MainActor @preconcurrency final public func play(completion: ((Swift.Bool) -> Swift.Void)?)
  @objc @_Concurrency.MainActor @preconcurrency final public func play(fromProgress: CoreFoundation.CGFloat, toProgress: CoreFoundation.CGFloat, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  @objc @_Concurrency.MainActor @preconcurrency final public func play(fromFrame: CoreFoundation.CGFloat, toFrame: CoreFoundation.CGFloat, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  @objc @_Concurrency.MainActor @preconcurrency final public func play(fromMarker: Swift.String, toMarker: Swift.String, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  @objc @_Concurrency.MainActor @preconcurrency final public func play(marker: Swift.String, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  @objc @_Concurrency.MainActor @preconcurrency final public func stop()
  @objc @_Concurrency.MainActor @preconcurrency final public func pause()
  @objc @_Concurrency.MainActor @preconcurrency final public func reloadImages()
  @objc @_Concurrency.MainActor @preconcurrency final public func forceDisplayUpdate()
  @objc @_Concurrency.MainActor @preconcurrency final public func getValue(for keypath: NECommonUIKit.NECompatibleAnimationKeypath, atFrame: CoreFoundation.CGFloat) -> Any?
  @objc @_Concurrency.MainActor @preconcurrency final public func logHierarchyKeypaths()
  @objc @_Concurrency.MainActor @preconcurrency final public func setColorValue(_ color: UIKit.UIColor, forKeypath keypath: NECommonUIKit.NECompatibleAnimationKeypath)
  @objc @_Concurrency.MainActor @preconcurrency final public func getColorValue(for keypath: NECommonUIKit.NECompatibleAnimationKeypath, atFrame: CoreFoundation.CGFloat) -> UIKit.UIColor?
  @objc @_Concurrency.MainActor @preconcurrency final public func addSubview(_ subview: NECommonUIKit.NEAnimationSubview, forLayerAt keypath: NECommonUIKit.NECompatibleAnimationKeypath)
  @objc @_Concurrency.MainActor @preconcurrency final public func convert(rect: CoreFoundation.CGRect, toLayerAt keypath: NECommonUIKit.NECompatibleAnimationKeypath?) -> CoreFoundation.CGRect
  @objc @_Concurrency.MainActor @preconcurrency final public func convert(point: CoreFoundation.CGPoint, toLayerAt keypath: NECommonUIKit.NECompatibleAnimationKeypath?) -> CoreFoundation.CGPoint
  @objc @_Concurrency.MainActor @preconcurrency final public func progressTime(forMarker named: Swift.String) -> CoreFoundation.CGFloat
  @objc @_Concurrency.MainActor @preconcurrency final public func frameTime(forMarker named: Swift.String) -> CoreFoundation.CGFloat
  @objc @_Concurrency.MainActor @preconcurrency final public func durationFrameTime(forMarker named: Swift.String) -> CoreFoundation.CGFloat
  @objc deinit
}
@objc final public class NECompatibleDictionaryTextProvider : ObjectiveC.NSObject {
  @objc public init(values: [Swift.String : Swift.String])
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @objcMembers public class NEConfigManager : ObjectiveC.NSObject {
  @objc public static let instance: NECommonUIKit.NEConfigManager
  @objc open func setParameter(key: Swift.String, value: Any?)
  @objc open func getParameter(key: Swift.String) -> Any?
  @objc override dynamic public init()
  @objc deinit
}
@objc @_Concurrency.MainActor @preconcurrency public class NECustomAlertAction : UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency public var showDefaultLine: Swift.Bool
  @_Concurrency.MainActor @preconcurrency public var contentText: UIKit.UILabel {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var clickAction: (() -> Swift.Void)?
  @_Concurrency.MainActor @preconcurrency public var cancelAction: (() -> Swift.Void)?
  @_Concurrency.MainActor @preconcurrency public var fillColor: UIKit.UIColor
  @_Concurrency.MainActor @preconcurrency public var edgeInset: UIKit.UIEdgeInsets
  @_Concurrency.MainActor @preconcurrency public var dividerLineLeftMargin: UIKit.NSLayoutConstraint?
  @_Concurrency.MainActor @preconcurrency public var dividerLineRightMargin: UIKit.NSLayoutConstraint?
  @_Concurrency.MainActor @preconcurrency public var cornerType: NECommonUIKit.CornerType {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var dividerLine: UIKit.UIView {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public init(title: Swift.String?, _ completion: (() -> Swift.Void)?)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func draw(_ rect: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency open func drawRoundedCorner(rect: CoreFoundation.CGRect)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objcMembers @_Concurrency.MainActor @preconcurrency public class NECustomActionSheetController : UIKit.UIViewController {
  @objc @_Concurrency.MainActor @preconcurrency public var cancelAction: NECommonUIKit.NECustomAlertAction {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency public var boldDividerLine: UIKit.UIView
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func viewDidLoad()
  @objc @_Concurrency.MainActor @preconcurrency open func addAction(_ action: NECommonUIKit.NECustomAlertAction, _ actionHeight: CoreFoundation.CGFloat = 51)
  @objc deinit
}
public enum NEDecodingStrategy : Swift.Hashable {
  case legacyCodable
  case dictionaryBased
  public static func == (a: NECommonUIKit.NEDecodingStrategy, b: NECommonUIKit.NEDecodingStrategy) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public class NEDefaultAnimationCache : NECommonUIKit.NEAnimationCacheProvider {
  public init()
  public static let sharedCache: NECommonUIKit.NEDefaultAnimationCache
  public var cacheSize: Swift.Int {
    get
    set
  }
  public func clearCache()
  public func animation(forKey key: Swift.String) -> NECommonUIKit.NELottieAnimation?
  public func setAnimation(_ animation: NECommonUIKit.NELottieAnimation, forKey key: Swift.String)
  @objc deinit
}
extension NECommonUIKit.NEDefaultAnimationCache : @unchecked Swift.Sendable {
}
public class NEDotLottieCache : NECommonUIKit.NEDotLottieCacheProvider {
  public init()
  public static let sharedCache: NECommonUIKit.NEDotLottieCache
  public var cacheSize: Swift.Int {
    get
    set
  }
  public func clearCache()
  public func file(forKey key: Swift.String) -> NECommonUIKit.NEDotLottieFile?
  public func setFile(_ lottie: NECommonUIKit.NEDotLottieFile, forKey key: Swift.String)
  @objc deinit
}
extension NECommonUIKit.NEDotLottieCache : @unchecked Swift.Sendable {
}
public protocol NEDotLottieCacheProvider : Swift.Sendable {
  func file(forKey: Swift.String) -> NECommonUIKit.NEDotLottieFile?
  func setFile(_ lottie: NECommonUIKit.NEDotLottieFile, forKey: Swift.String)
  func clearCache()
}
public struct NEDotLottieConfiguration {
  public var id: Swift.String
  public var loopMode: NECommonUIKit.NELottieLoopMode
  public var speed: Swift.Double
  public var imageProvider: (any NECommonUIKit.NEAnimationImageProvider)? {
    get
  }
}
public struct NEDotLottieConfigurationComponents : Swift.OptionSet {
  public init(rawValue: Swift.Int)
  public static let imageProvider: NECommonUIKit.NEDotLottieConfigurationComponents
  public static let loopMode: NECommonUIKit.NEDotLottieConfigurationComponents
  public static let animationSpeed: NECommonUIKit.NEDotLottieConfigurationComponents
  public static let all: NECommonUIKit.NEDotLottieConfigurationComponents
  public static let none: NECommonUIKit.NEDotLottieConfigurationComponents
  public let rawValue: Swift.Int
  public typealias ArrayLiteralElement = NECommonUIKit.NEDotLottieConfigurationComponents
  public typealias Element = NECommonUIKit.NEDotLottieConfigurationComponents
  public typealias RawValue = Swift.Int
}
@_hasMissingDesignatedInitializers final public class NEDotLottieFile {
  public struct Animation {
    public let animation: NECommonUIKit.NELottieAnimation
    public let configuration: NECommonUIKit.NEDotLottieConfiguration
  }
  final public var animations: [NECommonUIKit.NEDotLottieFile.Animation] {
    get
  }
  @objc deinit
}
extension NECommonUIKit.NEDotLottieFile : @unchecked Swift.Sendable {
}
extension NECommonUIKit.NEDotLottieFile {
  public enum NESynchronouslyBlockingCurrentThread {
    public static func loadedFrom(filepath: Swift.String, dotLottieCache: (any NECommonUIKit.NEDotLottieCacheProvider)? = NEDotLottieCache.sharedCache) -> Swift.Result<NECommonUIKit.NEDotLottieFile, any Swift.Error>
    public static func named(_ name: Swift.String, bundle: Foundation.Bundle = Bundle.main, subdirectory: Swift.String? = nil, dotLottieCache: (any NECommonUIKit.NEDotLottieCacheProvider)? = NEDotLottieCache.sharedCache) -> Swift.Result<NECommonUIKit.NEDotLottieFile, any Swift.Error>
    public static func loadedFrom(data: Foundation.Data, filename: Swift.String) -> Swift.Result<NECommonUIKit.NEDotLottieFile, any Swift.Error>
  }
  @available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  public static func named(_ name: Swift.String, bundle: Foundation.Bundle = Bundle.main, subdirectory: Swift.String? = nil, dotLottieCache: (any NECommonUIKit.NEDotLottieCacheProvider)? = NEDotLottieCache.sharedCache) async throws -> NECommonUIKit.NEDotLottieFile
  public static func named(_ name: Swift.String, bundle: Foundation.Bundle = Bundle.main, subdirectory: Swift.String? = nil, dotLottieCache: (any NECommonUIKit.NEDotLottieCacheProvider)? = NEDotLottieCache.sharedCache, dispatchQueue: Dispatch.DispatchQueue = .dotLottie, handleResult: @escaping (Swift.Result<NECommonUIKit.NEDotLottieFile, any Swift.Error>) -> Swift.Void)
  @available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  public static func loadedFrom(filepath: Swift.String, dotLottieCache: (any NECommonUIKit.NEDotLottieCacheProvider)? = NEDotLottieCache.sharedCache) async throws -> NECommonUIKit.NEDotLottieFile
  public static func loadedFrom(filepath: Swift.String, dotLottieCache: (any NECommonUIKit.NEDotLottieCacheProvider)? = NEDotLottieCache.sharedCache, dispatchQueue: Dispatch.DispatchQueue = .dotLottie, handleResult: @escaping (Swift.Result<NECommonUIKit.NEDotLottieFile, any Swift.Error>) -> Swift.Void)
  @available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  public static func asset(named name: Swift.String, bundle: Foundation.Bundle = Bundle.main, dotLottieCache: (any NECommonUIKit.NEDotLottieCacheProvider)? = NEDotLottieCache.sharedCache) async throws -> NECommonUIKit.NEDotLottieFile
  public static func asset(named name: Swift.String, bundle: Foundation.Bundle = Bundle.main, dotLottieCache: (any NECommonUIKit.NEDotLottieCacheProvider)? = NEDotLottieCache.sharedCache, dispatchQueue: Dispatch.DispatchQueue = .dotLottie, handleResult: @escaping (Swift.Result<NECommonUIKit.NEDotLottieFile, any Swift.Error>) -> Swift.Void)
  @available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  public static func loadedFrom(url: Foundation.URL, session: Foundation.URLSession = .shared, dotLottieCache: (any NECommonUIKit.NEDotLottieCacheProvider)? = NEDotLottieCache.sharedCache) async throws -> NECommonUIKit.NEDotLottieFile
  public static func loadedFrom(url: Foundation.URL, session: Foundation.URLSession = .shared, dotLottieCache: (any NECommonUIKit.NEDotLottieCacheProvider)? = NEDotLottieCache.sharedCache, handleResult: @escaping (Swift.Result<NECommonUIKit.NEDotLottieFile, any Swift.Error>) -> Swift.Void)
  public static func loadedFrom(data: Foundation.Data, filename: Swift.String, dispatchQueue: Dispatch.DispatchQueue = .dotLottie, handleResult: @escaping (Swift.Result<NECommonUIKit.NEDotLottieFile, any Swift.Error>) -> Swift.Void)
  @available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  public static func loadedFrom(data: Foundation.Data, filename: Swift.String, dispatchQueue: Dispatch.DispatchQueue = .dotLottie) async throws -> NECommonUIKit.NEDotLottieFile
}
extension Dispatch.DispatchQueue {
  public static let dotLottie: Dispatch.DispatchQueue
}
public enum NEDotLottieError : Swift.Error {
  case noDataLoaded
  case assetNotFound(name: Swift.String, bundle: Foundation.Bundle?)
  case loadingFromAssetNotSupported
  @available(*, deprecated, message: "Unused")
  case invalidFileFormat
  @available(*, deprecated, message: "Unused")
  case invalidData
  @available(*, deprecated, message: "Unused")
  case animationNotAvailable
}
@objc @objcMembers @_Concurrency.MainActor @preconcurrency open class NEEmptyDataView : UIKit.UIView {
  @objc @_Concurrency.MainActor @preconcurrency public var widthConstraint: UIKit.NSLayoutConstraint?
  @objc @_Concurrency.MainActor @preconcurrency public var heightConstraint: UIKit.NSLayoutConstraint?
  @objc @_Concurrency.MainActor @preconcurrency public var emptyImageView: UIKit.UIImageView {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency public init(imageName: Swift.String, content: Swift.String, frame: CoreFoundation.CGRect)
  @objc @_Concurrency.MainActor @preconcurrency public init(image: UIKit.UIImage?, content: Swift.String, frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc @_Concurrency.MainActor @preconcurrency open func setText(_ text: Swift.String?)
  @objc @_Concurrency.MainActor @preconcurrency open func setAttributedText(_ att: Foundation.NSAttributedString?)
  @objc @_Concurrency.MainActor @preconcurrency open func setEmptyImage(name: Swift.String)
  @objc @_Concurrency.MainActor @preconcurrency open func setEmptyImage(image: UIKit.UIImage?)
  @objc deinit
}
@available(iOS 13.0, tvOS 13.0, *)
@_Concurrency.MainActor @preconcurrency open class NEEpoxySwiftUIHostingController<Content> : SwiftUI.UIHostingController<Content> where Content : SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func viewDidLoad()
  @_Concurrency.MainActor @preconcurrency override public init(rootView: Content)
  @_Concurrency.MainActor @preconcurrency override public init?(coder aDecoder: Foundation.NSCoder, rootView: Content)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
}
public class NEFilepathImageProvider : NECommonUIKit.NEAnimationImageProvider {
  public init(filepath: Swift.String, contentsGravity: QuartzCore.CALayerContentsGravity = .resize)
  public init(filepath: Foundation.URL, contentsGravity: QuartzCore.CALayerContentsGravity = .resize)
  public func imageForAsset(asset: NECommonUIKit.NEImageAsset) -> CoreGraphics.CGImage?
  public func contentsGravity(for _: NECommonUIKit.NEImageAsset) -> QuartzCore.CALayerContentsGravity
  @objc deinit
}
extension NECommonUIKit.NEFilepathImageProvider : Swift.Equatable {
  public static func == (lhs: NECommonUIKit.NEFilepathImageProvider, rhs: NECommonUIKit.NEFilepathImageProvider) -> Swift.Bool
}
final public class NEFloatValueProvider {
  public init(block: @escaping NECommonUIKit.NEFloatValueProvider.CGFloatValueBlock)
  public init(_ float: CoreFoundation.CGFloat)
  public typealias CGFloatValueBlock = (CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  final public var float: CoreFoundation.CGFloat {
    get
    set
  }
  final public var valueType: any Any.Type {
    get
  }
  final public var storage: NECommonUIKit.NEValueProviderStorage<NECommonUIKit.NELottieVector1D> {
    get
  }
  final public func hasUpdate(frame _: CoreFoundation.CGFloat) -> Swift.Bool
  @objc deinit
}
extension NECommonUIKit.NEFloatValueProvider : Swift.Equatable {
  public static func == (lhs: NECommonUIKit.NEFloatValueProvider, rhs: NECommonUIKit.NEFloatValueProvider) -> Swift.Bool
}
final public class NEGradientValueProvider {
  public init(block: @escaping NECommonUIKit.NEGradientValueProvider.ColorsValueBlock, locations: NECommonUIKit.NEGradientValueProvider.ColorLocationsBlock? = nil)
  public init(_ colors: [NECommonUIKit.NELottieColor], locations: [Swift.Double] = [])
  public typealias ColorsValueBlock = (CoreFoundation.CGFloat) -> [NECommonUIKit.NELottieColor]
  public typealias ColorLocationsBlock = (CoreFoundation.CGFloat) -> [Swift.Double]
  final public var colors: [NECommonUIKit.NELottieColor] {
    get
    set
  }
  final public var locations: [Swift.Double] {
    get
    set
  }
  final public var valueType: any Any.Type {
    get
  }
  final public var storage: NECommonUIKit.NEValueProviderStorage<[Swift.Double]> {
    get
  }
  final public func hasUpdate(frame _: CoreFoundation.CGFloat) -> Swift.Bool
  @objc deinit
}
extension NECommonUIKit.NEGradientValueProvider : Swift.Equatable {
  public static func == (lhs: NECommonUIKit.NEGradientValueProvider, rhs: NECommonUIKit.NEGradientValueProvider) -> Swift.Bool
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency open class NEGrowingTextView : UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency weak open var delegate: (any NECommonUIKit.NEGrowingTextViewDelegate)?
  @_Concurrency.MainActor @preconcurrency open var internalTextView: UIKit.UITextView {
    get
  }
  @_Concurrency.MainActor @preconcurrency open var maxNumberOfLines: Swift.Int? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency open var minNumberOfLines: Swift.Int? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency open var maxHeight: CoreFoundation.CGFloat?
  @_Concurrency.MainActor @preconcurrency open var minHeight: CoreFoundation.CGFloat
  @_Concurrency.MainActor @preconcurrency open var isGrowingAnimationEnabled: Swift.Bool
  @_Concurrency.MainActor @preconcurrency open var animationDuration: Swift.Double
  @_Concurrency.MainActor @preconcurrency open var contentInset: UIKit.UIEdgeInsets {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency open var isScrollEnabled: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency open var isPlaceholderEnabled: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency open var placeholder: Foundation.NSAttributedString? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency open var isCaretHidden: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency open var text: Swift.String? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency open var font: UIKit.UIFont? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency open var textColor: UIKit.UIColor? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency open var textAlignment: UIKit.NSTextAlignment {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency open var isEditable: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency open var selectedRange: Foundation.NSRange? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency open var dataDetectorTypes: UIKit.UIDataDetectorTypes {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency open var returnKeyType: UIKit.UIReturnKeyType {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency open var keyboardType: UIKit.UIKeyboardType {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency open var enablesReturnKeyAutomatically: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency open var hasText: Swift.Bool {
    get
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
}
extension NECommonUIKit.NEGrowingTextView {
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var backgroundColor: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func layoutSubviews()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func sizeThatFits(_ size: CoreFoundation.CGSize) -> CoreFoundation.CGSize
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func touchesEnded(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func becomeFirstResponder() -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func resignFirstResponder() -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var isFirstResponder: Swift.Bool {
    @objc get
  }
}
extension NECommonUIKit.NEGrowingTextView {
  @_Concurrency.MainActor @preconcurrency public func scrollRangeToVisible(_ range: Foundation.NSRange)
  @_Concurrency.MainActor @preconcurrency public func calculateHeight() -> CoreFoundation.CGFloat
  @_Concurrency.MainActor @preconcurrency public func updateHeight()
}
extension NECommonUIKit.NEGrowingTextView : UIKit.UITextViewDelegate {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func textViewShouldBeginEditing(_ textView: UIKit.UITextView) -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func textViewShouldEndEditing(_ textView: UIKit.UITextView) -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func textViewDidBeginEditing(_ textView: UIKit.UITextView)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func textViewDidEndEditing(_ textView: UIKit.UITextView)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func textView(_ textView: UIKit.UITextView, shouldChangeTextIn range: Foundation.NSRange, replacementText text: Swift.String) -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func textViewDidChange(_ textView: UIKit.UITextView)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func textViewDidChangeSelection(_ textView: UIKit.UITextView)
}
@objc public protocol NEGrowingTextViewDelegate : ObjectiveC.NSObjectProtocol {
  @objc optional func growingTextViewShouldBeginEditing(_ growingTextView: NECommonUIKit.NEGrowingTextView) -> Swift.Bool
  @objc optional func growingTextViewShouldEndEditing(_ growingTextView: NECommonUIKit.NEGrowingTextView) -> Swift.Bool
  @objc optional func growingTextViewDidBeginEditing(_ growingTextView: NECommonUIKit.NEGrowingTextView)
  @objc optional func growingTextViewDidEndEditing(_ growingTextView: NECommonUIKit.NEGrowingTextView)
  @objc optional func growingTextView(_ growingTextView: NECommonUIKit.NEGrowingTextView, shouldChangeTextInRange range: Foundation.NSRange, replacementText text: Swift.String) -> Swift.Bool
  @objc optional func growingTextViewDidChange(_ growingTextView: NECommonUIKit.NEGrowingTextView)
  @objc optional func growingTextViewDidChangeSelection(_ growingTextView: NECommonUIKit.NEGrowingTextView)
  @objc optional func growingTextView(_ growingTextView: NECommonUIKit.NEGrowingTextView, willChangeHeight height: CoreFoundation.CGFloat, difference: CoreFoundation.CGFloat)
  @objc optional func growingTextView(_ growingTextView: NECommonUIKit.NEGrowingTextView, didChangeHeight height: CoreFoundation.CGFloat, difference: CoreFoundation.CGFloat)
  @objc optional func growingTextViewShouldReturn(_ growingTextView: NECommonUIKit.NEGrowingTextView) -> Swift.Bool
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class NEImageAsset : NECommonUIKit.NEAsset {
  final public let name: Swift.String
  final public let directory: Swift.String
  final public let width: Swift.Double
  final public let height: Swift.Double
  override final public func encode(to encoder: any Swift.Encoder) throws
  @objc deinit
}
public protocol NEInterpolatable : NECommonUIKit.NEAnyInterpolatable {
  func interpolate(to: Self, amount: CoreFoundation.CGFloat) -> Self
}
public protocol NESpatialInterpolatable : NECommonUIKit.NEAnyInterpolatable {
  func interpolate(to: Self, amount: CoreFoundation.CGFloat, spatialOutTangent: CoreFoundation.CGPoint?, spatialInTangent: CoreFoundation.CGPoint?) -> Self
}
public protocol NEAnyInterpolatable {
  func _interpolate(to: Self, amount: CoreFoundation.CGFloat, spatialOutTangent: CoreFoundation.CGPoint?, spatialInTangent: CoreFoundation.CGPoint?) -> Self
}
extension NECommonUIKit.NEInterpolatable {
  public func _interpolate(to: Self, amount: CoreFoundation.CGFloat, spatialOutTangent _: CoreFoundation.CGPoint?, spatialInTangent _: CoreFoundation.CGPoint?) -> Self
}
extension NECommonUIKit.NESpatialInterpolatable {
  public func interpolate(to: Self, amount: CoreFoundation.CGFloat) -> Self
  public func _interpolate(to: Self, amount: CoreFoundation.CGFloat, spatialOutTangent: CoreFoundation.CGPoint?, spatialInTangent: CoreFoundation.CGPoint?) -> Self
}
extension Swift.Double : NECommonUIKit.NEInterpolatable {
}
extension CoreFoundation.CGFloat : NECommonUIKit.NEInterpolatable {
}
extension Swift.Float : NECommonUIKit.NEInterpolatable {
}
extension NECommonUIKit.NEInterpolatable where Self : Swift.BinaryFloatingPoint {
  public func interpolate(to: Self, amount: CoreFoundation.CGFloat) -> Self
}
extension CoreFoundation.CGRect : NECommonUIKit.NEInterpolatable {
  public func interpolate(to: CoreFoundation.CGRect, amount: CoreFoundation.CGFloat) -> CoreFoundation.CGRect
}
extension CoreFoundation.CGSize : NECommonUIKit.NEInterpolatable {
  public func interpolate(to: CoreFoundation.CGSize, amount: CoreFoundation.CGFloat) -> CoreFoundation.CGSize
}
extension CoreFoundation.CGPoint : NECommonUIKit.NESpatialInterpolatable {
  public func interpolate(to: CoreFoundation.CGPoint, amount: CoreFoundation.CGFloat, spatialOutTangent: CoreFoundation.CGPoint?, spatialInTangent: CoreFoundation.CGPoint?) -> CoreFoundation.CGPoint
}
extension NECommonUIKit.NELottieColor : NECommonUIKit.NEInterpolatable {
  public func interpolate(to: NECommonUIKit.NELottieColor, amount: CoreFoundation.CGFloat) -> NECommonUIKit.NELottieColor
}
extension NECommonUIKit.NELottieVector1D : NECommonUIKit.NEInterpolatable {
  public func interpolate(to: NECommonUIKit.NELottieVector1D, amount: CoreFoundation.CGFloat) -> NECommonUIKit.NELottieVector1D
}
extension NECommonUIKit.NELottieVector2D : NECommonUIKit.NESpatialInterpolatable {
  public func interpolate(to: NECommonUIKit.NELottieVector2D, amount: CoreFoundation.CGFloat, spatialOutTangent: CoreFoundation.CGPoint?, spatialInTangent: CoreFoundation.CGPoint?) -> NECommonUIKit.NELottieVector2D
}
extension NECommonUIKit.NELottieVector3D : NECommonUIKit.NESpatialInterpolatable {
  public func interpolate(to: NECommonUIKit.NELottieVector3D, amount: CoreFoundation.CGFloat, spatialOutTangent: CoreFoundation.CGPoint?, spatialInTangent: CoreFoundation.CGPoint?) -> NECommonUIKit.NELottieVector3D
}
extension Swift.Array : NECommonUIKit.NEInterpolatable, NECommonUIKit.NEAnyInterpolatable where Element : NECommonUIKit.NEInterpolatable {
  public func interpolate(to: [Element], amount: CoreFoundation.CGFloat) -> [Element]
}
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Optional : NECommonUIKit.NEInterpolatable, NECommonUIKit.NEAnyInterpolatable where Wrapped : NECommonUIKit.NEInterpolatable {
  public func interpolate(to: Wrapped?, amount: CoreFoundation.CGFloat) -> Wrapped?
}
#else
extension Swift.Optional : NECommonUIKit.NEInterpolatable, NECommonUIKit.NEAnyInterpolatable where Wrapped : NECommonUIKit.NEInterpolatable {
  public func interpolate(to: Wrapped?, amount: CoreFoundation.CGFloat) -> Wrapped?
}
#endif
public enum NEInvalidationState {
  case nothing
  case everything
  case sizes
  public init(_ invalidationContext: UIKit.UICollectionViewLayoutInvalidationContext)
  public static func + (lhs: NECommonUIKit.NEInvalidationState, rhs: NECommonUIKit.NEInvalidationState) -> NECommonUIKit.NEInvalidationState
  public static func == (a: NECommonUIKit.NEInvalidationState, b: NECommonUIKit.NEInvalidationState) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOSApplicationExtension, unavailable)
@objc final public class NEInvocation : ObjectiveC.NSObject {
  @objc weak final public var target: Swift.AnyObject?
  @objc final public var action: ObjectiveC.Selector
  @objc public init(_ target: Swift.AnyObject, _ action: ObjectiveC.Selector)
  @objc final public func invoke(from: Any)
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOSApplicationExtension, unavailable)
@objc final public class NEKeyboardManager : ObjectiveC.NSObject {
  @objc public static let shared: NECommonUIKit.NEKeyboardManager
  @objc final public var enable: Swift.Bool {
    @objc get
    @objc set
  }
  @objc final public var keyboardDistanceFromTextField: CoreFoundation.CGFloat
  @objc final public var enableAutoToolbar: Swift.Bool {
    @objc get
    @objc set
  }
  @objc final public var toolbarManageBehaviour: NECommonUIKit.NEAutoToolbarManageBehaviour
  @objc final public var shouldToolbarUsesTextFieldTintColor: Swift.Bool
  @objc final public var toolbarTintColor: UIKit.UIColor?
  @objc final public var toolbarBarTintColor: UIKit.UIColor?
  @objc final public var previousNextDisplayMode: NECommonUIKit.NEPreviousNextDisplayMode
  @objc final public var toolbarPreviousBarButtonItemImage: UIKit.UIImage?
  @objc final public var toolbarNextBarButtonItemImage: UIKit.UIImage?
  @objc final public var toolbarDoneBarButtonItemImage: UIKit.UIImage?
  @objc final public var toolbarPreviousBarButtonItemText: Swift.String?
  @objc final public var toolbarPreviousBarButtonItemAccessibilityLabel: Swift.String?
  @objc final public var toolbarNextBarButtonItemText: Swift.String?
  @objc final public var toolbarNextBarButtonItemAccessibilityLabel: Swift.String?
  @objc final public var toolbarDoneBarButtonItemText: Swift.String?
  @objc final public var toolbarDoneBarButtonItemAccessibilityLabel: Swift.String?
  @objc final public var shouldShowToolbarPlaceholder: Swift.Bool
  @objc final public var placeholderFont: UIKit.UIFont?
  @objc final public var placeholderColor: UIKit.UIColor?
  @objc final public var placeholderButtonColor: UIKit.UIColor?
  @objc final public var overrideKeyboardAppearance: Swift.Bool
  @objc final public var keyboardAppearance: UIKit.UIKeyboardAppearance
  @objc final public var shouldResignOnTouchOutside: Swift.Bool {
    @objc get
    @objc set
  }
  @objc final public var resignFirstResponderGesture: UIKit.UITapGestureRecognizer {
    @objc get
    @objc set
  }
  @discardableResult
  @objc final public func resignFirstResponder() -> Swift.Bool
  @objc final public var shouldPlayInputClicks: Swift.Bool
  @objc final public var layoutIfNeededOnUpdate: Swift.Bool
  @objc final public var disabledDistanceHandlingClasses: [UIKit.UIViewController.Type]
  @objc final public var enabledDistanceHandlingClasses: [UIKit.UIViewController.Type]
  @objc final public var disabledToolbarClasses: [UIKit.UIViewController.Type]
  @objc final public var enabledToolbarClasses: [UIKit.UIViewController.Type]
  @objc final public var toolbarPreviousNextAllowedClasses: [UIKit.UIView.Type]
  @objc final public var disabledTouchResignedClasses: [UIKit.UIViewController.Type]
  @objc final public var enabledTouchResignedClasses: [UIKit.UIViewController.Type]
  @objc final public var touchResignedGestureIgnoreClasses: [UIKit.UIView.Type]
  @objc final public func registerTextFieldViewClass(_ aClass: UIKit.UIView.Type, didBeginEditingNotificationName: Swift.String, didEndEditingNotificationName: Swift.String)
  @objc final public func unregisterTextFieldViewClass(_ aClass: UIKit.UIView.Type, didBeginEditingNotificationName: Swift.String, didEndEditingNotificationName: Swift.String)
  @objc deinit
  @objc final public func reloadLayoutIfNeeded()
}
@available(iOSApplicationExtension, unavailable)
extension NECommonUIKit.NEKeyboardManager : UIKit.UIGestureRecognizerDelegate {
  @_Concurrency.MainActor @preconcurrency @objc final public func gestureRecognizer(_ gestureRecognizer: UIKit.UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIKit.UIGestureRecognizer) -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc final public func gestureRecognizer(_ gestureRecognizer: UIKit.UIGestureRecognizer, shouldReceive touch: UIKit.UITouch) -> Swift.Bool
}
@available(iOSApplicationExtension, unavailable)
extension NECommonUIKit.NEKeyboardManager {
  @objc final public var enableDebugging: Swift.Bool {
    @objc get
    @objc set(newValue)
  }
  @objc final public func registerAllNotifications()
  @objc final public func unregisterAllNotifications()
  public enum Static {
  }
}
@available(iOSApplicationExtension, unavailable)
extension NECommonUIKit.NEKeyboardManager {
  @objc final public var movedDistance: CoreFoundation.CGFloat {
    @objc get
  }
  @objc final public var movedDistanceChanged: ((CoreFoundation.CGFloat) -> Swift.Void)? {
    @objc get
    @objc set(newValue)
  }
}
@available(iOSApplicationExtension, unavailable)
extension NECommonUIKit.NEKeyboardManager {
  @objc final public func reloadInputViews()
}
@available(iOSApplicationExtension, unavailable)
extension NECommonUIKit.NEKeyboardManager {
  @objc final public var canGoPrevious: Swift.Bool {
    @objc get
  }
  @objc final public var canGoNext: Swift.Bool {
    @objc get
  }
  @discardableResult
  @objc final public func goPrevious() -> Swift.Bool
  @discardableResult
  @objc final public func goNext() -> Swift.Bool
}
@available(iOSApplicationExtension, unavailable)
extension NECommonUIKit.NEKeyboardManager {
  @objc final public var keyboardShowing: Swift.Bool {
    @objc get
  }
}
@available(iOSApplicationExtension, unavailable)
@objc public enum NEAutoToolbarManageBehaviour : Swift.Int {
  case bySubviews
  case byTag
  case byPosition
  public init?(rawValue: Swift.Int)
  @available(iOSApplicationExtension, unavailable)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@available(iOSApplicationExtension, unavailable)
@objc public enum NEPreviousNextDisplayMode : Swift.Int {
  case `default`
  case alwaysHide
  case alwaysShow
  public init?(rawValue: Swift.Int)
  @available(iOSApplicationExtension, unavailable)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@available(iOSApplicationExtension, unavailable)
@objc public enum NEEnableMode : Swift.Int {
  case `default`
  case enabled
  case disabled
  public init?(rawValue: Swift.Int)
  @available(iOSApplicationExtension, unavailable)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @available(iOSApplicationExtension, unavailable)
@objc final public class NEKeyboardReturnKeyHandler : ObjectiveC.NSObject {
  @objc weak final public var delegate: (any UIKit.UITextFieldDelegate & UIKit.UITextViewDelegate)?
  @objc final public var lastTextFieldReturnKeyType: UIKit.UIReturnKeyType {
    @objc get
    @objc set
  }
  @objc override dynamic public init()
  @objc public init(controller: UIKit.UIViewController)
  @objc deinit
  @objc final public func addTextFieldView(_ view: UIKit.UIView)
  @objc final public func removeTextFieldView(_ view: UIKit.UIView)
  @objc final public func addResponderFromView(_ view: UIKit.UIView)
  @objc final public func removeResponderFromView(_ view: UIKit.UIView)
}
@available(iOSApplicationExtension, unavailable)
extension NECommonUIKit.NEKeyboardReturnKeyHandler : UIKit.UITextFieldDelegate {
  @_Concurrency.MainActor @preconcurrency @objc final public func textFieldShouldBeginEditing(_ textField: UIKit.UITextField) -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc final public func textFieldShouldEndEditing(_ textField: UIKit.UITextField) -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc final public func textFieldDidBeginEditing(_ textField: UIKit.UITextField)
  @_Concurrency.MainActor @preconcurrency @objc final public func textFieldDidEndEditing(_ textField: UIKit.UITextField)
  @available(iOS 10.0, *)
  @_Concurrency.MainActor @preconcurrency @objc final public func textFieldDidEndEditing(_ textField: UIKit.UITextField, reason: UIKit.UITextField.DidEndEditingReason)
  @_Concurrency.MainActor @preconcurrency @objc final public func textField(_ textField: UIKit.UITextField, shouldChangeCharactersIn range: Foundation.NSRange, replacementString string: Swift.String) -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc final public func textFieldShouldClear(_ textField: UIKit.UITextField) -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc final public func textFieldShouldReturn(_ textField: UIKit.UITextField) -> Swift.Bool
}
@available(iOSApplicationExtension, unavailable)
extension NECommonUIKit.NEKeyboardReturnKeyHandler : UIKit.UITextViewDelegate {
  @_Concurrency.MainActor @preconcurrency @objc final public func textViewShouldBeginEditing(_ textView: UIKit.UITextView) -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc final public func textViewShouldEndEditing(_ textView: UIKit.UITextView) -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc final public func textViewDidBeginEditing(_ textView: UIKit.UITextView)
  @_Concurrency.MainActor @preconcurrency @objc final public func textViewDidEndEditing(_ textView: UIKit.UITextView)
  @_Concurrency.MainActor @preconcurrency @objc final public func textView(_ textView: UIKit.UITextView, shouldChangeTextIn range: Foundation.NSRange, replacementText text: Swift.String) -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc final public func textViewDidChange(_ textView: UIKit.UITextView)
  @_Concurrency.MainActor @preconcurrency @objc final public func textViewDidChangeSelection(_ textView: UIKit.UITextView)
  @available(iOS 10.0, *)
  @_Concurrency.MainActor @preconcurrency @objc final public func textView(_ aTextView: UIKit.UITextView, shouldInteractWith URL: Foundation.URL, in characterRange: Foundation.NSRange, interaction: UIKit.UITextItemInteraction) -> Swift.Bool
  @available(iOS 10.0, *)
  @_Concurrency.MainActor @preconcurrency @objc final public func textView(_ aTextView: UIKit.UITextView, shouldInteractWith textAttachment: UIKit.NSTextAttachment, in characterRange: Foundation.NSRange, interaction: UIKit.UITextItemInteraction) -> Swift.Bool
  @available(iOS, deprecated: 10.0)
  @_Concurrency.MainActor @preconcurrency @objc final public func textView(_ aTextView: UIKit.UITextView, shouldInteractWith URL: Foundation.URL, in characterRange: Foundation.NSRange) -> Swift.Bool
  @available(iOS, deprecated: 10.0)
  @_Concurrency.MainActor @preconcurrency @objc final public func textView(_ aTextView: UIKit.UITextView, shouldInteractWith textAttachment: UIKit.NSTextAttachment, in characterRange: Foundation.NSRange) -> Swift.Bool
}
final public class NEKeyframe<T> {
  public init(_ value: T, spatialInTangent: NECommonUIKit.NELottieVector3D? = nil, spatialOutTangent: NECommonUIKit.NELottieVector3D? = nil)
  public init(value: T, time: NECommonUIKit.NEAnimationFrameTime, isHold: Swift.Bool = false, inTangent: NECommonUIKit.NELottieVector2D? = nil, outTangent: NECommonUIKit.NELottieVector2D? = nil, spatialInTangent: NECommonUIKit.NELottieVector3D? = nil, spatialOutTangent: NECommonUIKit.NELottieVector3D? = nil)
  final public let value: T
  final public let time: NECommonUIKit.NEAnimationFrameTime
  final public let isHold: Swift.Bool
  final public let inTangent: NECommonUIKit.NELottieVector2D?
  final public let outTangent: NECommonUIKit.NELottieVector2D?
  final public let spatialInTangent: NECommonUIKit.NELottieVector3D?
  final public let spatialOutTangent: NECommonUIKit.NELottieVector3D?
  @objc deinit
}
extension NECommonUIKit.NEKeyframe : Swift.Equatable where T : Swift.Equatable {
  public static func == (lhs: NECommonUIKit.NEKeyframe<T>, rhs: NECommonUIKit.NEKeyframe<T>) -> Swift.Bool
}
extension NECommonUIKit.NEKeyframe : Swift.Hashable where T : Swift.Hashable {
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
extension NECommonUIKit.NEKeyframe : Swift.Sendable where T : Swift.Sendable {
}
extension QuartzCore.CALayer {
  @nonobjc public func logLayerTree(withIndent: Swift.Int = 0)
}
public enum NELayerType : Swift.Int, Swift.Codable {
  case precomp
  case solid
  case image
  case null
  case shape
  case text
  case unknown
  public init(from decoder: any Swift.Decoder) throws
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum NEMatteType : Swift.Int, Swift.Codable {
  case none
  case add
  case invert
  case unknown
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum NEBlendMode : Swift.Int, Swift.Codable {
  case normal
  case multiply
  case screen
  case overlay
  case darken
  case lighten
  case colorDodge
  case colorBurn
  case hardLight
  case softLight
  case difference
  case exclusion
  case hue
  case saturation
  case color
  case luminosity
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public protocol LinkableLabelProtocol {
  @objc optional func didTapLink(url: Foundation.URL?)
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objcMembers @_Concurrency.MainActor @preconcurrency open class NELinkableLabel : UIKit.UILabel {
  @objc @_Concurrency.MainActor @preconcurrency weak public var delegate: (any NECommonUIKit.LinkableLabelProtocol)?
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc @_Concurrency.MainActor @preconcurrency public func updateLinkDetection()
  @objc deinit
}
public enum NECoordinateSpace : Swift.Int, Swift.Codable, Swift.Sendable {
  case type2d
  case type3d
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
final public class NELottieAnimation : Swift.Codable, Swift.Sendable {
  required public init(from decoder: any Swift.Decoder) throws
  public init(dictionary: [Swift.String : Any]) throws
  final public let startFrame: NECommonUIKit.NEAnimationFrameTime
  final public let endFrame: NECommonUIKit.NEAnimationFrameTime
  final public let framerate: Swift.Double
  final public var markerNames: [Swift.String] {
    get
  }
  @objc deinit
  final public func encode(to encoder: any Swift.Encoder) throws
}
public enum NELottieAnimationCache {
  public static var shared: (any NECommonUIKit.NEAnimationCacheProvider)?
}
extension NECommonUIKit.NELottieAnimation {
  public typealias DownloadClosure = (NECommonUIKit.NELottieAnimation?) -> Swift.Void
  final public var duration: Foundation.TimeInterval {
    get
  }
  final public var bounds: CoreFoundation.CGRect {
    get
  }
  final public var size: CoreFoundation.CGSize {
    get
  }
  public static func named(_ name: Swift.String, bundle: Foundation.Bundle = Bundle.main, subdirectory: Swift.String? = nil, animationCache: (any NECommonUIKit.NEAnimationCacheProvider)? = NELottieAnimationCache.shared) -> NECommonUIKit.NELottieAnimation?
  public static func filepath(_ filepath: Swift.String, animationCache: (any NECommonUIKit.NEAnimationCacheProvider)? = NELottieAnimationCache.shared) -> NECommonUIKit.NELottieAnimation?
  public static func asset(_ name: Swift.String, bundle: Foundation.Bundle = Bundle.main, animationCache: (any NECommonUIKit.NEAnimationCacheProvider)? = NELottieAnimationCache.shared) -> NECommonUIKit.NELottieAnimation?
  public static func from(data: Foundation.Data, strategy: NECommonUIKit.NEDecodingStrategy = NELottieConfiguration.shared.decodingStrategy) throws -> NECommonUIKit.NELottieAnimation
  @available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  public static func loadedFrom(url: Foundation.URL, session: Foundation.URLSession = .shared, animationCache: (any NECommonUIKit.NEAnimationCacheProvider)? = NELottieAnimationCache.shared) async -> NECommonUIKit.NELottieAnimation?
  public static func loadedFrom(url: Foundation.URL, session: Foundation.URLSession = .shared, closure: @escaping NECommonUIKit.NELottieAnimation.DownloadClosure, animationCache: (any NECommonUIKit.NEAnimationCacheProvider)? = NELottieAnimationCache.shared)
  final public func progressTime(forMarker named: Swift.String) -> NECommonUIKit.NEAnimationProgressTime?
  final public func frameTime(forMarker named: Swift.String) -> NECommonUIKit.NEAnimationFrameTime?
  final public func durationFrameTime(forMarker named: Swift.String) -> NECommonUIKit.NEAnimationFrameTime?
  final public func progressTime(forFrame frameTime: NECommonUIKit.NEAnimationFrameTime, clamped: Swift.Bool = true) -> NECommonUIKit.NEAnimationProgressTime
  final public func frameTime(forProgress progressTime: NECommonUIKit.NEAnimationProgressTime) -> NECommonUIKit.NEAnimationFrameTime
  final public func time(forFrame frameTime: NECommonUIKit.NEAnimationFrameTime) -> Foundation.TimeInterval
  final public func frameTime(forTime time: Foundation.TimeInterval) -> NECommonUIKit.NEAnimationFrameTime
}
extension Foundation.Bundle : @unchecked Swift.Sendable {
}
@objc @_hasMissingDesignatedInitializers public class NELottieAnimationLayer : QuartzCore.CALayer {
  public init(animation: NECommonUIKit.NELottieAnimation?, imageProvider: (any NECommonUIKit.NEAnimationImageProvider)? = nil, textProvider: any NECommonUIKit.NEAnimationKeypathTextProvider = NEDefaultTextProvider(), fontProvider: any NECommonUIKit.NEAnimationFontProvider = NEDefaultFontProvider(), configuration: NECommonUIKit.NELottieConfiguration = .shared, logger: NECommonUIKit.NELottieLogger = .shared)
  public init(dotLottie: NECommonUIKit.NEDotLottieFile?, animationId: Swift.String? = nil, textProvider: any NECommonUIKit.NEAnimationKeypathTextProvider = NEDefaultTextProvider(), fontProvider: any NECommonUIKit.NEAnimationFontProvider = NEDefaultFontProvider(), configuration: NECommonUIKit.NELottieConfiguration = .shared, logger: NECommonUIKit.NELottieLogger = .shared)
  public init(configuration: NECommonUIKit.NELottieConfiguration = .shared, logger: NECommonUIKit.NELottieLogger = .shared)
  open func play(completion: NECommonUIKit.NELottieCompletionBlock? = nil)
  open func play(fromProgress: NECommonUIKit.NEAnimationProgressTime? = nil, toProgress: NECommonUIKit.NEAnimationProgressTime, loopMode: NECommonUIKit.NELottieLoopMode? = nil, completion: NECommonUIKit.NELottieCompletionBlock? = nil)
  open func play(fromFrame: NECommonUIKit.NEAnimationFrameTime? = nil, toFrame: NECommonUIKit.NEAnimationFrameTime, loopMode: NECommonUIKit.NELottieLoopMode? = nil, completion: NECommonUIKit.NELottieCompletionBlock? = nil)
  open func play(fromMarker: Swift.String? = nil, toMarker: Swift.String, playEndMarkerFrame: Swift.Bool = true, loopMode: NECommonUIKit.NELottieLoopMode? = nil, completion: NECommonUIKit.NELottieCompletionBlock? = nil)
  open func play(marker: Swift.String, loopMode: NECommonUIKit.NELottieLoopMode? = nil, completion: NECommonUIKit.NELottieCompletionBlock? = nil)
  open func play(markers: [Swift.String], completion: NECommonUIKit.NELottieCompletionBlock? = nil)
  open func stop()
  open func pause()
  open func pause(at state: NECommonUIKit.NELottiePlaybackMode.PausedState)
  @available(*, deprecated, renamed: "setPlaybackMode(_:completion:)", message: "Will be removed in a future major release.")
  open func play(_ playbackMode: NECommonUIKit.NELottiePlaybackMode, animationCompletionHandler: NECommonUIKit.NELottieCompletionBlock? = nil)
  open func setPlaybackMode(_ playbackMode: NECommonUIKit.NELottiePlaybackMode, completion: NECommonUIKit.NELottieCompletionBlock? = nil)
  open func play(_ playbackMode: NECommonUIKit.NELottiePlaybackMode.PlaybackMode, completion: NECommonUIKit.NELottieCompletionBlock? = nil)
  public var currentPlaybackMode: NECommonUIKit.NELottiePlaybackMode? {
    get
  }
  public var valueProviders: [NECommonUIKit.NEAnimationKeypath : any NECommonUIKit.NEAnyValueProvider] {
    get
  }
  public var animationLayerDidLoad: ((_ animationLayer: NECommonUIKit.NELottieAnimationLayer, _ renderingEngine: NECommonUIKit.NERenderingEngineOption) -> Swift.Void)?
  public var configuration: NECommonUIKit.NELottieConfiguration {
    get
    set
  }
  public var animationLayer: QuartzCore.CALayer? {
    get
  }
  public var screenScale: CoreFoundation.CGFloat {
    get
    set
  }
  public var backgroundBehavior: NECommonUIKit.NELottieBackgroundBehavior {
    get
    set
  }
  public var animation: NECommonUIKit.NELottieAnimation? {
    get
    set
  }
  public var animationLoaded: ((_ animationLayer: NECommonUIKit.NELottieAnimationLayer, _ animation: NECommonUIKit.NELottieAnimation) -> Swift.Void)? {
    get
    set
  }
  public var imageProvider: any NECommonUIKit.NEAnimationImageProvider {
    get
    set
  }
  public var textProvider: any NECommonUIKit.NEAnimationKeypathTextProvider {
    get
    set
  }
  public var fontProvider: any NECommonUIKit.NEAnimationFontProvider {
    get
    set
  }
  public var maskAnimationToBounds: Swift.Bool {
    get
    set
  }
  public var isAnimationPlaying: Swift.Bool {
    get
  }
  public var loopMode: NECommonUIKit.NELottieLoopMode {
    get
    set
  }
  public var shouldRasterizeWhenIdle: Swift.Bool {
    get
    set
  }
  public var currentProgress: NECommonUIKit.NEAnimationProgressTime {
    get
    set
  }
  public var currentTime: Foundation.TimeInterval {
    get
    set
  }
  public var currentFrame: NECommonUIKit.NEAnimationFrameTime {
    get
    set
  }
  public var realtimeAnimationFrame: NECommonUIKit.NEAnimationFrameTime {
    get
  }
  public var realtimeAnimationProgress: NECommonUIKit.NEAnimationProgressTime {
    get
  }
  public var animationSpeed: CoreFoundation.CGFloat {
    get
    set
  }
  public var respectAnimationFrameRate: Swift.Bool {
    get
    set
  }
  public var currentRenderingEngine: NECommonUIKit.NERenderingEngine? {
    get
  }
  public var mainThreadRenderingEngineShouldForceDisplayUpdateOnEachFrame: Swift.Bool {
    get
    set
  }
  public func loadAnimation(_ animationId: Swift.String? = nil, from dotLottieFile: NECommonUIKit.NEDotLottieFile)
  public func loadAnimation(atIndex index: Swift.Int, from dotLottieFile: NECommonUIKit.NEDotLottieFile)
  public func reloadImages()
  public func forceDisplayUpdate()
  public func setValueProvider(_ valueProvider: any NECommonUIKit.NEAnyValueProvider, keypath: NECommonUIKit.NEAnimationKeypath)
  public func getValue(for keypath: NECommonUIKit.NEAnimationKeypath, atFrame: NECommonUIKit.NEAnimationFrameTime?) -> Any?
  public func getOriginalValue(for keypath: NECommonUIKit.NEAnimationKeypath, atFrame: NECommonUIKit.NEAnimationFrameTime?) -> Any?
  public func logHierarchyKeypaths()
  public func allHierarchyKeypaths() -> [Swift.String]
  public func convert(_ rect: CoreFoundation.CGRect, toLayerAt keypath: NECommonUIKit.NEAnimationKeypath?) -> CoreFoundation.CGRect?
  public func convert(_ point: CoreFoundation.CGPoint, toLayerAt keypath: NECommonUIKit.NEAnimationKeypath?) -> CoreFoundation.CGPoint?
  public func setNodeIsEnabled(isEnabled: Swift.Bool, keypath: NECommonUIKit.NEAnimationKeypath)
  public func progressTime(forMarker named: Swift.String) -> NECommonUIKit.NEAnimationProgressTime?
  public func frameTime(forMarker named: Swift.String) -> NECommonUIKit.NEAnimationFrameTime?
  public func durationFrameTime(forMarker named: Swift.String) -> NECommonUIKit.NEAnimationFrameTime?
  public func updateAnimationForBackgroundState()
  public func updateAnimationForForegroundState(wasWaitingToPlayAnimation: Swift.Bool)
  @objc deinit
}
public enum NELottieAnimationSource : Swift.Sendable {
  case lottieAnimation(NECommonUIKit.NELottieAnimation)
  case dotLottieFile(NECommonUIKit.NEDotLottieFile)
}
extension NECommonUIKit.NELottieAnimation {
  final public var animationSource: NECommonUIKit.NELottieAnimationSource {
    get
  }
}
extension NECommonUIKit.NEDotLottieFile {
  final public var animationSource: NECommonUIKit.NELottieAnimationSource {
    get
  }
}
public enum NELottieBackgroundBehavior {
  case stop
  case pause
  case pauseAndRestore
  case forceFinish
  case continuePlaying
  public static func `default`(for renderingEngine: NECommonUIKit.NERenderingEngine) -> NECommonUIKit.NELottieBackgroundBehavior
  public static func == (a: NECommonUIKit.NELottieBackgroundBehavior, b: NECommonUIKit.NELottieBackgroundBehavior) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum NELottieLoopMode : Swift.Hashable {
  case playOnce
  case loop
  case autoReverse
  case `repeat`(Swift.Float)
  case repeatBackwards(Swift.Float)
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension NECommonUIKit.NELottieLoopMode : Swift.Equatable {
  public static func == (lhs: NECommonUIKit.NELottieLoopMode, rhs: NECommonUIKit.NELottieLoopMode) -> Swift.Bool
}
@objc @_inheritsConvenienceInitializers @IBDesignable @_Concurrency.MainActor @preconcurrency open class NELottieAnimationView : NECommonUIKit.NELottieAnimationViewBase {
  @_Concurrency.MainActor @preconcurrency public init(animation: NECommonUIKit.NELottieAnimation?, imageProvider: (any NECommonUIKit.NEAnimationImageProvider)? = nil, textProvider: any NECommonUIKit.NEAnimationKeypathTextProvider = NEDefaultTextProvider(), fontProvider: any NECommonUIKit.NEAnimationFontProvider = NEDefaultFontProvider(), configuration: NECommonUIKit.NELottieConfiguration = .shared, logger: NECommonUIKit.NELottieLogger = .shared)
  @_Concurrency.MainActor @preconcurrency public init(dotLottie: NECommonUIKit.NEDotLottieFile?, animationId: Swift.String? = nil, textProvider: any NECommonUIKit.NEAnimationKeypathTextProvider = NEDefaultTextProvider(), fontProvider: any NECommonUIKit.NEAnimationFontProvider = NEDefaultFontProvider(), configuration: NECommonUIKit.NELottieConfiguration = .shared, logger: NECommonUIKit.NELottieLogger = .shared)
  @_Concurrency.MainActor @preconcurrency public init(configuration: NECommonUIKit.NELottieConfiguration = .shared, logger: NECommonUIKit.NELottieLogger = .shared)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency open func play(_ mode: NECommonUIKit.NELottiePlaybackMode.PlaybackMode, completion: NECommonUIKit.NELottieCompletionBlock? = nil)
  @_Concurrency.MainActor @preconcurrency open func play(completion: NECommonUIKit.NELottieCompletionBlock? = nil)
  @_Concurrency.MainActor @preconcurrency open func play(fromProgress: NECommonUIKit.NEAnimationProgressTime? = nil, toProgress: NECommonUIKit.NEAnimationProgressTime, loopMode: NECommonUIKit.NELottieLoopMode? = nil, completion: NECommonUIKit.NELottieCompletionBlock? = nil)
  @_Concurrency.MainActor @preconcurrency open func play(fromFrame: NECommonUIKit.NEAnimationFrameTime? = nil, toFrame: NECommonUIKit.NEAnimationFrameTime, loopMode: NECommonUIKit.NELottieLoopMode? = nil, completion: NECommonUIKit.NELottieCompletionBlock? = nil)
  @_Concurrency.MainActor @preconcurrency open func play(fromMarker: Swift.String? = nil, toMarker: Swift.String, playEndMarkerFrame: Swift.Bool = true, loopMode: NECommonUIKit.NELottieLoopMode? = nil, completion: NECommonUIKit.NELottieCompletionBlock? = nil)
  @_Concurrency.MainActor @preconcurrency open func play(marker: Swift.String, loopMode: NECommonUIKit.NELottieLoopMode? = nil, completion: NECommonUIKit.NELottieCompletionBlock? = nil)
  @_Concurrency.MainActor @preconcurrency open func play(markers: [Swift.String], completion: NECommonUIKit.NELottieCompletionBlock? = nil)
  @_Concurrency.MainActor @preconcurrency open func stop()
  @_Concurrency.MainActor @preconcurrency open func pause()
  @available(*, deprecated, renamed: "setNEPlaybackMode(_:completion:)", message: "Will be removed in a future major release.")
  @_Concurrency.MainActor @preconcurrency open func play(_ playbackMode: NECommonUIKit.NELottiePlaybackMode, animationCompletionHandler: NECommonUIKit.NELottieCompletionBlock? = nil)
  @_Concurrency.MainActor @preconcurrency open func setPlaybackMode(_ playbackMode: NECommonUIKit.NELottiePlaybackMode, completion: NECommonUIKit.NELottieCompletionBlock? = nil)
  @_Concurrency.MainActor @preconcurrency public var animateLayoutChangesWithCurrentCoreAnimationContext: Swift.Bool
  @_Concurrency.MainActor @preconcurrency public var configuration: NECommonUIKit.NELottieConfiguration {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var valueProviders: [NECommonUIKit.NEAnimationKeypath : any NECommonUIKit.NEAnyValueProvider] {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var backgroundBehavior: NECommonUIKit.NELottieBackgroundBehavior {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var animation: NECommonUIKit.NELottieAnimation? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var animationLoaded: ((_ animationView: NECommonUIKit.NELottieAnimationView, _ animation: NECommonUIKit.NELottieAnimation) -> Swift.Void)? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var imageProvider: any NECommonUIKit.NEAnimationImageProvider {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var textProvider: any NECommonUIKit.NEAnimationKeypathTextProvider {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var fontProvider: any NECommonUIKit.NEAnimationFontProvider {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var maskAnimationToBounds: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var isAnimationPlaying: Swift.Bool {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var isAnimationQueued: Swift.Bool {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var loopMode: NECommonUIKit.NELottieLoopMode {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var shouldRasterizeWhenIdle: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var currentProgress: NECommonUIKit.NEAnimationProgressTime {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var currentTime: Foundation.TimeInterval {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var currentFrame: NECommonUIKit.NEAnimationFrameTime {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var realtimeAnimationFrame: NECommonUIKit.NEAnimationFrameTime {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var realtimeAnimationProgress: NECommonUIKit.NEAnimationProgressTime {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var animationSpeed: CoreFoundation.CGFloat {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var respectAnimationFrameRate: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var viewportFrame: CoreFoundation.CGRect? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
  @_Concurrency.MainActor @preconcurrency public var currentRenderingEngine: NECommonUIKit.NERenderingEngine? {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var currentPlaybackMode: NECommonUIKit.NELottiePlaybackMode? {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var mainThreadRenderingEngineShouldForceDisplayUpdateOnEachFrame: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public func loadAnimation(_ animationId: Swift.String? = nil, from dotLottieFile: NECommonUIKit.NEDotLottieFile)
  @_Concurrency.MainActor @preconcurrency public func loadAnimation(atIndex index: Swift.Int, from dotLottieFile: NECommonUIKit.NEDotLottieFile)
  @_Concurrency.MainActor @preconcurrency public func reloadImages()
  @_Concurrency.MainActor @preconcurrency public func forceDisplayUpdate()
  @_Concurrency.MainActor @preconcurrency public func setValueProvider(_ valueProvider: any NECommonUIKit.NEAnyValueProvider, keypath: NECommonUIKit.NEAnimationKeypath)
  @_Concurrency.MainActor @preconcurrency public func getValue(for keypath: NECommonUIKit.NEAnimationKeypath, atFrame: NECommonUIKit.NEAnimationFrameTime?) -> Any?
  @_Concurrency.MainActor @preconcurrency public func getOriginalValue(for keypath: NECommonUIKit.NEAnimationKeypath, atFrame: NECommonUIKit.NEAnimationFrameTime?) -> Any?
  @_Concurrency.MainActor @preconcurrency public func logHierarchyKeypaths()
  @_Concurrency.MainActor @preconcurrency public func allHierarchyKeypaths() -> [Swift.String]
  @_Concurrency.MainActor @preconcurrency public func addSubview(_ subview: NECommonUIKit.NEAnimationSubview, forLayerAt keypath: NECommonUIKit.NEAnimationKeypath)
  @_Concurrency.MainActor @preconcurrency public func convert(_ rect: CoreFoundation.CGRect, toLayerAt keypath: NECommonUIKit.NEAnimationKeypath?) -> CoreFoundation.CGRect?
  @_Concurrency.MainActor @preconcurrency public func convert(_ point: CoreFoundation.CGPoint, toLayerAt keypath: NECommonUIKit.NEAnimationKeypath?) -> CoreFoundation.CGPoint?
  @_Concurrency.MainActor @preconcurrency public func setNodeIsEnabled(isEnabled: Swift.Bool, keypath: NECommonUIKit.NEAnimationKeypath)
  @_Concurrency.MainActor @preconcurrency public func progressTime(forMarker named: Swift.String) -> NECommonUIKit.NEAnimationProgressTime?
  @_Concurrency.MainActor @preconcurrency public func frameTime(forMarker named: Swift.String) -> NECommonUIKit.NEAnimationFrameTime?
  @_Concurrency.MainActor @preconcurrency public func durationFrameTime(forMarker named: Swift.String) -> NECommonUIKit.NEAnimationFrameTime?
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency open class NELottieAnimationViewBase : UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public var contentMode: UIKit.UIView.ContentMode {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func didMoveToWindow()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func layoutSubviews()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
extension NECommonUIKit.NELottieAnimationView {
  @_Concurrency.MainActor @preconcurrency convenience public init(name: Swift.String, bundle: Foundation.Bundle = Bundle.main, subdirectory: Swift.String? = nil, imageProvider: (any NECommonUIKit.NEAnimationImageProvider)? = nil, animationCache: (any NECommonUIKit.NEAnimationCacheProvider)? = NELottieAnimationCache.shared, configuration: NECommonUIKit.NELottieConfiguration = .shared)
  @_Concurrency.MainActor @preconcurrency convenience public init(filePath: Swift.String, imageProvider: (any NECommonUIKit.NEAnimationImageProvider)? = nil, animationCache: (any NECommonUIKit.NEAnimationCacheProvider)? = NELottieAnimationCache.shared, configuration: NECommonUIKit.NELottieConfiguration = .shared)
  @_Concurrency.MainActor @preconcurrency convenience public init(url: Foundation.URL, imageProvider: (any NECommonUIKit.NEAnimationImageProvider)? = nil, session: Foundation.URLSession = .shared, closure: @escaping NECommonUIKit.NELottieAnimationView.DownloadClosure, animationCache: (any NECommonUIKit.NEAnimationCacheProvider)? = NELottieAnimationCache.shared, configuration: NECommonUIKit.NELottieConfiguration = .shared)
  @_Concurrency.MainActor @preconcurrency convenience public init(asset name: Swift.String, bundle: Foundation.Bundle = Bundle.main, imageProvider: (any NECommonUIKit.NEAnimationImageProvider)? = nil, animationCache: (any NECommonUIKit.NEAnimationCacheProvider)? = NELottieAnimationCache.shared, configuration: NECommonUIKit.NELottieConfiguration = .shared)
  @_Concurrency.MainActor @preconcurrency convenience public init(dotLottieName name: Swift.String, bundle: Foundation.Bundle = Bundle.main, subdirectory: Swift.String? = nil, animationId: Swift.String? = nil, dotLottieCache: (any NECommonUIKit.NEDotLottieCacheProvider)? = NEDotLottieCache.sharedCache, configuration: NECommonUIKit.NELottieConfiguration = .shared, completion: ((NECommonUIKit.NELottieAnimationView, (any Swift.Error)?) -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency convenience public init(dotLottieFilePath filePath: Swift.String, animationId: Swift.String? = nil, dotLottieCache: (any NECommonUIKit.NEDotLottieCacheProvider)? = NEDotLottieCache.sharedCache, configuration: NECommonUIKit.NELottieConfiguration = .shared, completion: ((NECommonUIKit.NELottieAnimationView, (any Swift.Error)?) -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency convenience public init(dotLottieUrl url: Foundation.URL, animationId: Swift.String? = nil, dotLottieCache: (any NECommonUIKit.NEDotLottieCacheProvider)? = NEDotLottieCache.sharedCache, configuration: NECommonUIKit.NELottieConfiguration = .shared, session: Foundation.URLSession = .shared, completion: ((NECommonUIKit.NELottieAnimationView, (any Swift.Error)?) -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency convenience public init(dotLottieAsset name: Swift.String, bundle: Foundation.Bundle = Bundle.main, animationId: Swift.String? = nil, dotLottieCache: (any NECommonUIKit.NEDotLottieCacheProvider)? = NEDotLottieCache.sharedCache, configuration: NECommonUIKit.NELottieConfiguration = .shared, completion: ((NECommonUIKit.NELottieAnimationView, (any Swift.Error)?) -> Swift.Void)? = nil)
  public typealias DownloadClosure = ((any Swift.Error)?) -> Swift.Void
}
@available(iOS 13.0, tvOS 13.0, macOS 10.15, *)
@_Concurrency.MainActor @preconcurrency public struct NELottieButton {
  @_Concurrency.MainActor @preconcurrency public init(animation: NECommonUIKit.NELottieAnimation?, action: @escaping () -> Swift.Void)
  @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
    get
  }
  @_Concurrency.MainActor @preconcurrency public func configure(_ configure: @escaping (NECommonUIKit.NEAnimatedButton) -> Swift.Void) -> NECommonUIKit.NELottieButton
  @_Concurrency.MainActor @preconcurrency public func configuration(_ configuration: NECommonUIKit.NELottieConfiguration) -> NECommonUIKit.NELottieButton
  @_Concurrency.MainActor @preconcurrency public func animate(fromProgress: NECommonUIKit.NEAnimationProgressTime, toProgress: NECommonUIKit.NEAnimationProgressTime, on event: NECommonUIKit.NELottieControlEvent) -> NECommonUIKit.NELottieButton
  @_Concurrency.MainActor @preconcurrency public func animate(fromMarker: Swift.String, toMarker: Swift.String, on event: NECommonUIKit.NELottieControlEvent) -> NECommonUIKit.NELottieButton
  @_Concurrency.MainActor @preconcurrency public func valueProvider<NEValueProvider>(_ valueProvider: NEValueProvider, for keypath: NECommonUIKit.NEAnimationKeypath) -> NECommonUIKit.NELottieButton where NEValueProvider : NECommonUIKit.NEAnyValueProvider, NEValueProvider : Swift.Equatable
  @available(iOS 13.0, tvOS 13.0, macOS 10.15, *)
  public typealias Body = @_opaqueReturnTypeOf("$s13NECommonUIKit14NELottieButtonV4bodyQrvp", 0) __
}
public enum NEColorFormatDenominator : Swift.Hashable {
  case One
  case OneHundred
  case TwoFiftyFive
  public static func == (a: NECommonUIKit.NEColorFormatDenominator, b: NECommonUIKit.NEColorFormatDenominator) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct NELottieColor : Swift.Hashable {
  public var r: Swift.Double
  public var g: Swift.Double
  public var b: Swift.Double
  public var a: Swift.Double
  public init(r: Swift.Double, g: Swift.Double, b: Swift.Double, a: Swift.Double, denominator: NECommonUIKit.NEColorFormatDenominator = .One)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: NECommonUIKit.NELottieColor, b: NECommonUIKit.NELottieColor) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct NELottieConfiguration : Swift.Hashable {
  public init(renderingEngine: NECommonUIKit.NERenderingEngineOption = .automatic, decodingStrategy: NECommonUIKit.NEDecodingStrategy = .dictionaryBased, colorSpace: CoreGraphics.CGColorSpace = CGColorSpaceCreateDeviceRGB(), reducedMotionOption: NECommonUIKit.NEReducedMotionOption = .systemReducedMotionToggle)
  public static var shared: NECommonUIKit.NELottieConfiguration
  public var renderingEngine: NECommonUIKit.NERenderingEngineOption
  public var decodingStrategy: NECommonUIKit.NEDecodingStrategy
  public var reducedMotionOption: NECommonUIKit.NEReducedMotionOption
  public var colorSpace: CoreGraphics.CGColorSpace
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: NECommonUIKit.NELottieConfiguration, b: NECommonUIKit.NELottieConfiguration) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
final public class NELottieLogger {
  public init(assert: @escaping NECommonUIKit.NELottieLogger.Assert = { condition, message, file, line in
     
     
     
    Swift.assert(condition(), message(), file: file, line: line)
  }, assertionFailure: @escaping NECommonUIKit.NELottieLogger.AssertionFailure = { message, file, line in
     
     
     
     
    Swift.assertionFailure(message(), file: file, line: line)
  }, warn: @escaping NECommonUIKit.NELottieLogger.Warn = { message, _, _ in
  }, info: @escaping NECommonUIKit.NELottieLogger.Info = { message in
  })
  public typealias Assert = (_ condition: @autoclosure () -> Swift.Bool, _ message: @autoclosure () -> Swift.String, _ fileID: Swift.StaticString, _ line: Swift.UInt) -> Swift.Void
  public typealias AssertionFailure = (_ message: @autoclosure () -> Swift.String, _ fileID: Swift.StaticString, _ line: Swift.UInt) -> Swift.Void
  public typealias Warn = (_ message: @autoclosure () -> Swift.String, _ fileID: Swift.StaticString, _ line: Swift.UInt) -> Swift.Void
  public typealias Info = (_ message: @autoclosure () -> Swift.String) -> Swift.Void
  public static var shared: NECommonUIKit.NELottieLogger
  final public func assert(_ condition: @autoclosure () -> Swift.Bool, _ message: @autoclosure () -> Swift.String = String(), fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
  final public func assertionFailure(_ message: @autoclosure () -> Swift.String = String(), fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
  final public func warn(_ message: @autoclosure () -> Swift.String = String(), fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
  final public func info(_ message: @autoclosure () -> Swift.String = String())
  @objc deinit
}
extension NECommonUIKit.NELottieLogger {
  public static var printToConsole: NECommonUIKit.NELottieLogger {
    get
  }
}
public enum NELottiePlaybackMode : Swift.Hashable {
  case paused(at: NECommonUIKit.NELottiePlaybackMode.PausedState)
  case playing(_: NECommonUIKit.NELottiePlaybackMode.PlaybackMode)
  @available(*, deprecated, renamed: "NELottiePlaybackMode.paused(at:)", message: "Will be removed in a future major release.")
  case progress(_: NECommonUIKit.NEAnimationProgressTime)
  @available(*, deprecated, renamed: "NELottiePlaybackMode.paused(at:)", message: "Will be removed in a future major release.")
  case frame(_: NECommonUIKit.NEAnimationFrameTime)
  @available(*, deprecated, renamed: "NELottiePlaybackMode.paused(at:)", message: "Will be removed in a future major release.")
  case time(_: Foundation.TimeInterval)
  @available(*, deprecated, renamed: "NELottiePlaybackMode.paused(at:)", message: "Will be removed in a future major release.")
  case pause
  @available(*, deprecated, renamed: "NELottiePlaybackMode.playing(_:)", message: "Will be removed in a future major release.")
  case fromProgress(_: NECommonUIKit.NEAnimationProgressTime?, toProgress: NECommonUIKit.NEAnimationProgressTime, loopMode: NECommonUIKit.NELottieLoopMode)
  @available(*, deprecated, renamed: "NELottiePlaybackMode.playing(_:)", message: "Will be removed in a future major release.")
  case fromFrame(_: NECommonUIKit.NEAnimationFrameTime?, toFrame: NECommonUIKit.NEAnimationFrameTime, loopMode: NECommonUIKit.NELottieLoopMode)
  @available(*, deprecated, renamed: "NELottiePlaybackMode.playing(_:)", message: "Will be removed in a future major release.")
  case fromMarker(_: Swift.String?, toMarker: Swift.String, playEndMarkerFrame: Swift.Bool = true, loopMode: NECommonUIKit.NELottieLoopMode)
  @available(*, deprecated, renamed: "NELottiePlaybackMode.playing(_:)", message: "Will be removed in a future major release.")
  case marker(_: Swift.String, loopMode: NECommonUIKit.NELottieLoopMode)
  @available(*, deprecated, renamed: "NELottiePlaybackMode.playing(_:)", message: "Will be removed in a future major release.")
  case markers(_: [Swift.String])
  public enum PausedState : Swift.Hashable {
    case currentFrame
    case progress(_: NECommonUIKit.NEAnimationProgressTime)
    case frame(_: NECommonUIKit.NEAnimationFrameTime)
    case time(_: Foundation.TimeInterval)
    case marker(_: Swift.String, position: NECommonUIKit.NELottieMarkerPosition = .start)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: NECommonUIKit.NELottiePlaybackMode.PausedState, b: NECommonUIKit.NELottiePlaybackMode.PausedState) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum PlaybackMode : Swift.Hashable {
    case fromProgress(_: NECommonUIKit.NEAnimationProgressTime?, toProgress: NECommonUIKit.NEAnimationProgressTime, loopMode: NECommonUIKit.NELottieLoopMode)
    case fromFrame(_: NECommonUIKit.NEAnimationFrameTime?, toFrame: NECommonUIKit.NEAnimationFrameTime, loopMode: NECommonUIKit.NELottieLoopMode)
    case fromMarker(_: Swift.String?, toMarker: Swift.String, playEndMarkerFrame: Swift.Bool = true, loopMode: NECommonUIKit.NELottieLoopMode)
    case marker(_: Swift.String, loopMode: NECommonUIKit.NELottieLoopMode)
    case markers(_: [Swift.String])
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: NECommonUIKit.NELottiePlaybackMode.PlaybackMode, b: NECommonUIKit.NELottiePlaybackMode.PlaybackMode) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: NECommonUIKit.NELottiePlaybackMode, b: NECommonUIKit.NELottiePlaybackMode) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension NECommonUIKit.NELottiePlaybackMode {
  public static var paused: NECommonUIKit.NELottiePlaybackMode {
    get
  }
  @available(*, deprecated, renamed: "NELottiePlaybackMode.playing(_:)", message: "Will be removed in a future major release.")
  public static func toProgress(_ toProgress: NECommonUIKit.NEAnimationProgressTime, loopMode: NECommonUIKit.NELottieLoopMode) -> NECommonUIKit.NELottiePlaybackMode
  @available(*, deprecated, renamed: "NELottiePlaybackMode.playing(_:)", message: "Will be removed in a future major release.")
  public static func toFrame(_ toFrame: NECommonUIKit.NEAnimationFrameTime, loopMode: NECommonUIKit.NELottieLoopMode) -> NECommonUIKit.NELottiePlaybackMode
  @available(*, deprecated, renamed: "NELottiePlaybackMode.playing(_:)", message: "Will be removed in a future major release.")
  public static func toMarker(_ toMarker: Swift.String, playEndMarkerFrame: Swift.Bool = true, loopMode: NECommonUIKit.NELottieLoopMode) -> NECommonUIKit.NELottiePlaybackMode
}
extension NECommonUIKit.NELottiePlaybackMode.PlaybackMode {
  public static func toProgress(_ toProgress: NECommonUIKit.NEAnimationProgressTime, loopMode: NECommonUIKit.NELottieLoopMode) -> NECommonUIKit.NELottiePlaybackMode.PlaybackMode
  public static func toFrame(_ toFrame: NECommonUIKit.NEAnimationFrameTime, loopMode: NECommonUIKit.NELottieLoopMode) -> NECommonUIKit.NELottiePlaybackMode.PlaybackMode
  public static func toMarker(_ toMarker: Swift.String, playEndMarkerFrame: Swift.Bool = true, loopMode: NECommonUIKit.NELottieLoopMode) -> NECommonUIKit.NELottiePlaybackMode.PlaybackMode
}
public enum NELottieMarkerPosition : Swift.Hashable {
  case start
  case end
  public static func == (a: NECommonUIKit.NELottieMarkerPosition, b: NECommonUIKit.NELottieMarkerPosition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 13.0, tvOS 13.0, macOS 10.15, *)
@_Concurrency.MainActor @preconcurrency public struct NELottieSwitch {
  @_Concurrency.MainActor @preconcurrency public init(animation: NECommonUIKit.NELottieAnimation?)
  @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
    get
  }
  @_Concurrency.MainActor @preconcurrency public func configure(_ configure: @escaping (NECommonUIKit.NEAnimatedSwitch) -> Swift.Void) -> NECommonUIKit.NELottieSwitch
  @_Concurrency.MainActor @preconcurrency public func configuration(_ configuration: NECommonUIKit.NELottieConfiguration) -> NECommonUIKit.NELottieSwitch
  @_Concurrency.MainActor @preconcurrency public func isOn(_ binding: SwiftUICore.Binding<Swift.Bool>) -> NECommonUIKit.NELottieSwitch
  @_Concurrency.MainActor @preconcurrency public func onAnimation(fromProgress onStartProgress: NECommonUIKit.NEAnimationProgressTime, toProgress onEndProgress: NECommonUIKit.NEAnimationProgressTime) -> NECommonUIKit.NELottieSwitch
  @_Concurrency.MainActor @preconcurrency public func offAnimation(fromProgress offStartProgress: NECommonUIKit.NEAnimationProgressTime, toProgress offEndProgress: NECommonUIKit.NEAnimationProgressTime) -> NECommonUIKit.NELottieSwitch
  @_Concurrency.MainActor @preconcurrency public func valueProvider<NEValueProvider>(_ valueProvider: NEValueProvider, for keypath: NECommonUIKit.NEAnimationKeypath) -> NECommonUIKit.NELottieSwitch where NEValueProvider : NECommonUIKit.NEAnyValueProvider, NEValueProvider : Swift.Equatable
  @available(iOS 13.0, tvOS 13.0, macOS 10.15, *)
  public typealias Body = @_opaqueReturnTypeOf("$s13NECommonUIKit14NELottieSwitchV4bodyQrvp", 0) __
}
@available(iOS 13.0, tvOS 13.0, macOS 10.15, *)
@_Concurrency.MainActor @preconcurrency public struct NELottieView<Placeholder> where Placeholder : SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency public init(animation: NECommonUIKit.NELottieAnimation?) where Placeholder == SwiftUICore.EmptyView
  @_Concurrency.MainActor @preconcurrency public init(dotLottieFile: NECommonUIKit.NEDotLottieFile?) where Placeholder == SwiftUICore.EmptyView
  @_Concurrency.MainActor @preconcurrency public init(_ loadAnimation: @escaping () async throws -> NECommonUIKit.NELottieAnimation?) where Placeholder == SwiftUICore.EmptyView
  @_Concurrency.MainActor @preconcurrency public init(_ loadAnimation: @escaping () async throws -> NECommonUIKit.NELottieAnimation?, @SwiftUICore.ViewBuilder placeholder: @escaping (() -> Placeholder))
  @_Concurrency.MainActor @preconcurrency public init(_ loadDotLottieFile: @escaping () async throws -> NECommonUIKit.NEDotLottieFile?) where Placeholder == SwiftUICore.EmptyView
  @_Concurrency.MainActor @preconcurrency public init(_ loadDotLottieFile: @escaping () async throws -> NECommonUIKit.NEDotLottieFile?, @SwiftUICore.ViewBuilder placeholder: @escaping (() -> Placeholder))
  @_Concurrency.MainActor @preconcurrency public init(_ loadAnimation: @escaping () async throws -> NECommonUIKit.NELottieAnimationSource?) where Placeholder == SwiftUICore.EmptyView
  @_Concurrency.MainActor @preconcurrency public init(_ loadAnimation: @escaping () async throws -> NECommonUIKit.NELottieAnimationSource?, @SwiftUICore.ViewBuilder placeholder: @escaping () -> Placeholder)
  @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
    get
  }
  @_Concurrency.MainActor @preconcurrency public func configure(_ configure: @escaping (NECommonUIKit.NELottieAnimationView) -> Swift.Void) -> NECommonUIKit.NELottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func resizable() -> NECommonUIKit.NELottieView<Placeholder>
  @available(*, deprecated, renamed: "playing()", message: "Will be removed in a future major release.")
  @_Concurrency.MainActor @preconcurrency public func play() -> NECommonUIKit.NELottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func looping() -> NECommonUIKit.NELottieView<Placeholder>
  @available(*, deprecated, renamed: "playing(_:)", message: "Will be removed in a future major release.")
  @_Concurrency.MainActor @preconcurrency public func play(loopMode: NECommonUIKit.NELottieLoopMode = .playOnce) -> NECommonUIKit.NELottieView<Placeholder>
  @available(*, deprecated, renamed: "playbackMode(_:)", message: "Will be removed in a future major release.")
  @_Concurrency.MainActor @preconcurrency public func play(_ playbackMode: NECommonUIKit.NELottiePlaybackMode) -> NECommonUIKit.NELottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func playing(_ mode: NECommonUIKit.NELottiePlaybackMode.PlaybackMode) -> NECommonUIKit.NELottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func playing(loopMode: NECommonUIKit.NELottieLoopMode) -> NECommonUIKit.NELottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func playing() -> NECommonUIKit.NELottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func paused(at state: NECommonUIKit.NELottiePlaybackMode.PausedState = .currentFrame) -> NECommonUIKit.NELottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func playbackMode(_ playbackMode: NECommonUIKit.NELottiePlaybackMode) -> NECommonUIKit.NELottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func animationSpeed(_ animationSpeed: Swift.Double) -> NECommonUIKit.NELottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func animationDidLoad(_ animationDidLoad: @escaping (NECommonUIKit.NELottieAnimationSource) -> Swift.Void) -> NECommonUIKit.NELottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func animationDidFinish(_ animationCompletionHandler: NECommonUIKit.NELottieCompletionBlock?) -> NECommonUIKit.NELottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func backgroundBehavior(_ value: NECommonUIKit.NELottieBackgroundBehavior) -> NECommonUIKit.NELottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func accessibilityLabel(_ accessibilityLabel: Swift.String?) -> NECommonUIKit.NELottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func configuration(_ configuration: NECommonUIKit.NELottieConfiguration) -> NECommonUIKit.NELottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func logger(_ logger: NECommonUIKit.NELottieLogger) -> NECommonUIKit.NELottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func imageProvider<NEImageProvider>(_ imageProvider: NEImageProvider) -> NECommonUIKit.NELottieView<Placeholder> where NEImageProvider : NECommonUIKit.NEAnimationImageProvider, NEImageProvider : Swift.Equatable
  @_Concurrency.MainActor @preconcurrency public func textProvider<NETextProvider>(_ textProvider: NETextProvider) -> NECommonUIKit.NELottieView<Placeholder> where NETextProvider : NECommonUIKit.NEAnimationKeypathTextProvider, NETextProvider : Swift.Equatable
  @_Concurrency.MainActor @preconcurrency public func fontProvider<NEFontProvider>(_ fontProvider: NEFontProvider) -> NECommonUIKit.NELottieView<Placeholder> where NEFontProvider : NECommonUIKit.NEAnimationFontProvider, NEFontProvider : Swift.Equatable
  @_Concurrency.MainActor @preconcurrency public func valueProvider<NEValueProvider>(_ valueProvider: NEValueProvider, for keypath: NECommonUIKit.NEAnimationKeypath) -> NECommonUIKit.NELottieView<Placeholder> where NEValueProvider : NECommonUIKit.NEAnyValueProvider, NEValueProvider : Swift.Equatable
  @_Concurrency.MainActor @preconcurrency public func currentProgress(_ currentProgress: NECommonUIKit.NEAnimationProgressTime?) -> NECommonUIKit.NELottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func currentFrame(_ currentFrame: NECommonUIKit.NEAnimationFrameTime?) -> NECommonUIKit.NELottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func currentTime(_ currentTime: Foundation.TimeInterval?) -> NECommonUIKit.NELottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func reloadAnimationTrigger(_ value: some Equatable, showPlaceholder: Swift.Bool = true) -> NECommonUIKit.NELottieView<Placeholder>
  @available(iOS 15.0, tvOS 15.0, macOS 12.0, *)
  @_Concurrency.MainActor @preconcurrency public func getRealtimeAnimationProgress(_ realtimeAnimationProgress: SwiftUICore.Binding<NECommonUIKit.NEAnimationProgressTime>?) -> some SwiftUICore.View
  
  @available(iOS 15.0, tvOS 15.0, macOS 12.0, *)
  @_Concurrency.MainActor @preconcurrency public func getRealtimeAnimationFrame(_ realtimeAnimationFrame: SwiftUICore.Binding<NECommonUIKit.NEAnimationFrameTime>?) -> some SwiftUICore.View
  
  @_Concurrency.MainActor @preconcurrency public func dotLottieConfigurationComponents(_ dotLottieConfigurationComponents: NECommonUIKit.NEDotLottieConfigurationComponents) -> NECommonUIKit.NELottieView<Placeholder>
  @available(iOS 13.0, tvOS 13.0, macOS 10.15, *)
  public typealias Body = @_opaqueReturnTypeOf("$s13NECommonUIKit12NELottieViewV4bodyQrvp", 0) __<Placeholder>
}
public typealias NELottieControlType = UIKit.UIControl
public typealias NELottieControlState = UIKit.UIControl.State
public typealias NELottieControlEvent = UIKit.UIControl.Event
@available(*, deprecated, message: "Use NEDefaultAnimationCache instead, which is thread-safe and automatically responds to memory pressure.")
public typealias NELRUAnimationCache = NECommonUIKit.NEDefaultAnimationCache
infix operator +| : DefaultPrecedence
infix operator +- : DefaultPrecedence
@objc @_inheritsConvenienceInitializers @objcMembers @_Concurrency.MainActor @preconcurrency open class NENavigationController : UIKit.UINavigationController {
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func viewDidLoad()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func pushViewController(_ viewController: UIKit.UIViewController, animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func popToViewController(_ viewController: UIKit.UIViewController, animated: Swift.Bool) -> [UIKit.UIViewController]?
  @available(iOS 5.0, *)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(navigationBarClass: Swift.AnyClass?, toolbarClass: Swift.AnyClass?)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(rootViewController: UIKit.UIViewController)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @objcMembers @_Concurrency.MainActor @preconcurrency open class NENavigationView : UIKit.UIView {
  @objc @_Concurrency.MainActor @preconcurrency public var bottomMargin: CoreFoundation.CGFloat
  @objc @_Concurrency.MainActor @preconcurrency public var leftMargin: CoreFoundation.CGFloat
  @objc @_Concurrency.MainActor @preconcurrency public var titleBarBottomLineHeightAnchor: UIKit.NSLayoutConstraint?
  @objc @_Concurrency.MainActor @preconcurrency public var backButtonWidthAnchor: UIKit.NSLayoutConstraint?
  @objc @_Concurrency.MainActor @preconcurrency public var moreButtonWidthAnchor: UIKit.NSLayoutConstraint?
  @objc @_Concurrency.MainActor @preconcurrency public var backButton: UIKit.UIButton {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency public var navTitle: UIKit.UILabel {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency public var moreButton: UIKit.UIButton {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency public var titleBarView: UIKit.UIView {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency public var titleBarBottomLine: UIKit.UIView {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc @_Concurrency.MainActor @preconcurrency open func setupUI()
  @objc @_Concurrency.MainActor @preconcurrency open func setBackButtonTitle(_ title: Swift.String)
  @objc @_Concurrency.MainActor @preconcurrency open func setBackButtonImage(_ image: UIKit.UIImage?)
  @objc @_Concurrency.MainActor @preconcurrency open func setBackButtonWidth(_ width: CoreFoundation.CGFloat)
  @objc @_Concurrency.MainActor @preconcurrency open func addBackButtonTarget(target: Any?, selector: ObjectiveC.Selector)
  @objc @_Concurrency.MainActor @preconcurrency open func setMoreButtonTitle(_ title: Swift.String)
  @objc @_Concurrency.MainActor @preconcurrency open func setMoreButtonImage(_ image: UIKit.UIImage?)
  @objc @_Concurrency.MainActor @preconcurrency open func setMoreButtonWidth(_ width: CoreFoundation.CGFloat)
  @objc @_Concurrency.MainActor @preconcurrency open func addMoreButtonTarget(target: Any?, selector: ObjectiveC.Selector)
  @objc @_Concurrency.MainActor @preconcurrency open func setTitleBarBottomLineHeight(_ height: CoreFoundation.CGFloat)
  @objc @_Concurrency.MainActor @preconcurrency open func setNavigationBackgroundColor(_ color: UIKit.UIColor)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency public class NEOverlayFocusView : UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency public var contentBackgroundColor: UIKit.UIColor? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func layoutSubviews()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency public class NEOverlayMenuCell : NECommonUIKit.NEPagingMenuViewCell {
  @_Concurrency.MainActor @preconcurrency weak public var referencedMenuView: NECommonUIKit.NETabPagingMenuView?
  @_Concurrency.MainActor @preconcurrency weak public var referencedFocusView: NECommonUIKit.PagingMenuFocusView?
  @_Concurrency.MainActor @preconcurrency public var hightlightTextColor: UIKit.UIColor? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var normalTextColor: UIKit.UIColor? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var hightlightTextFont: UIKit.UIFont? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var normalTextFont: UIKit.UIFont? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public static let sizingCell: NECommonUIKit.NEOverlayMenuCell
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func layoutSubviews()
  @_Concurrency.MainActor @preconcurrency public func configure(title: Swift.String)
  @_Concurrency.MainActor @preconcurrency public func updateMask(animated: Swift.Bool = true)
  @_Concurrency.MainActor @preconcurrency public func calculateWidth(from height: CoreFoundation.CGFloat, title: Swift.String) -> CoreFoundation.CGFloat
  @objc deinit
}
@objc @objcMembers @_Concurrency.MainActor @preconcurrency open class NEPageViewController : UIKit.UIViewController {
  @_Concurrency.MainActor @preconcurrency weak public var dataSource: (any NECommonUIKit.NEPageViewControllerDataSource)?
  @_Concurrency.MainActor @preconcurrency weak public var delegate: (any NECommonUIKit.NEPageViewControllerDelegate)?
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public var shouldAutomaticallyForwardAppearanceMethods: Swift.Bool {
    @objc get
  }
  @objc @_Concurrency.MainActor @preconcurrency public var beforeViewController: UIKit.UIViewController? {
    @objc get
  }
  @objc @_Concurrency.MainActor @preconcurrency public var selectedViewController: UIKit.UIViewController? {
    @objc get
  }
  @objc @_Concurrency.MainActor @preconcurrency public var scrollView: UIKit.UIScrollView {
    @objc get
  }
  @_Concurrency.MainActor @preconcurrency public var options: NECommonUIKit.NEPagingOptions {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public init(options: NECommonUIKit.NEPagingOptions = NEPagingOptions())
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewWillLayoutSubviews()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewWillAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewWillDisappear(_ animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidDisappear(_ animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewWillTransition(to size: CoreFoundation.CGSize, with coordinator: any UIKit.UIViewControllerTransitionCoordinator)
  @_Concurrency.MainActor @preconcurrency public func selectViewController(_ viewController: UIKit.UIViewController, direction: NECommonUIKit.NEPageViewDirection, animated: Swift.Bool = true)
  @objc @_Concurrency.MainActor @preconcurrency public func selectNext(animated: Swift.Bool)
  @objc @_Concurrency.MainActor @preconcurrency public func selectPrevious(animated: Swift.Bool)
  @objc @_Concurrency.MainActor @preconcurrency public func removeAll()
  @objc deinit
}
extension NECommonUIKit.NEPageViewController : UIKit.UIScrollViewDelegate {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func scrollViewWillBeginDragging(_: UIKit.UIScrollView)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func scrollViewWillEndDragging(_: UIKit.UIScrollView, withVelocity _: CoreFoundation.CGPoint, targetContentOffset _: Swift.UnsafeMutablePointer<CoreFoundation.CGPoint>)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func scrollViewDidScroll(_: UIKit.UIScrollView)
}
public protocol NEPageViewControllerDataSource : AnyObject {
  func pageViewController(_ pageViewController: NECommonUIKit.NEPageViewController, viewControllerBeforeViewController viewController: UIKit.UIViewController) -> UIKit.UIViewController?
  func pageViewController(_ pageViewController: NECommonUIKit.NEPageViewController, viewControllerAfterViewController viewController: UIKit.UIViewController) -> UIKit.UIViewController?
}
public protocol NEPageViewControllerDelegate : AnyObject {
  func pageViewController(_ pageViewController: NECommonUIKit.NEPageViewController, willStartScrollingFrom startingViewController: UIKit.UIViewController, destinationViewController: UIKit.UIViewController)
  func pageViewController(_ pageViewController: NECommonUIKit.NEPageViewController, isScrollingFrom startingViewController: UIKit.UIViewController, destinationViewController: UIKit.UIViewController?, progress: CoreFoundation.CGFloat)
  func pageViewController(_ pageViewController: NECommonUIKit.NEPageViewController, didFinishScrollingFrom startingViewController: UIKit.UIViewController, destinationViewController: UIKit.UIViewController, transitionSuccessful: Swift.Bool)
}
public enum NEPageViewDirection {
  case forward
  case reverse
  case none
  public static func == (a: NECommonUIKit.NEPageViewDirection, b: NECommonUIKit.NEPageViewDirection) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency open class NEPagingBorderLayoutAttributes : UIKit.UICollectionViewLayoutAttributes {
  @_Concurrency.MainActor @preconcurrency open var backgroundColor: UIKit.UIColor?
  @_Concurrency.MainActor @preconcurrency open var insets: UIKit.UIEdgeInsets
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func copy(with zone: ObjectiveC.NSZone? = nil) -> Any
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func isEqual(_ object: Any?) -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init()
  @objc deinit
}
public enum NEPagingBorderOptions {
  case hidden
  case visible(height: CoreFoundation.CGFloat, zIndex: Swift.Int, insets: UIKit.UIEdgeInsets)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency open class NEPagingBorderView : UIKit.UICollectionReusableView {
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func apply(_ layoutAttributes: UIKit.UICollectionViewLayoutAttributes)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency open class NEPagingCell : UIKit.UICollectionViewCell {
  @_Concurrency.MainActor @preconcurrency open func setPagingItem(_: any NECommonUIKit.NEPagingItem, selected _: Swift.Bool, options _: NECommonUIKit.NEPagingOptions)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency open class NEPagingCellLayoutAttributes : UIKit.UICollectionViewLayoutAttributes {
  @_Concurrency.MainActor @preconcurrency open var progress: CoreFoundation.CGFloat
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func copy(with zone: ObjectiveC.NSZone? = nil) -> Any
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func isEqual(_ object: Any?) -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency open class NEPagingCollectionViewLayout : UIKit.UICollectionViewLayout {
  @_Concurrency.MainActor @preconcurrency public var options: NECommonUIKit.NEPagingOptions {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var state: NECommonUIKit.NEPagingState
  @_Concurrency.MainActor @preconcurrency public var visibleItems: NECommonUIKit.NEPagingItems
  @_Concurrency.MainActor @preconcurrency public var layoutAttributes: [Foundation.IndexPath : NECommonUIKit.NEPagingCellLayoutAttributes] {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var indicatorLayoutAttributes: NECommonUIKit.NEPagingIndicatorLayoutAttributes? {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var borderLayoutAttributes: NECommonUIKit.NEPagingBorderLayoutAttributes? {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var invalidationState: NECommonUIKit.NEInvalidationState
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var collectionViewContentSize: CoreFoundation.CGSize {
    @objc get
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open class var layoutAttributesClass: Swift.AnyClass {
    @objc get
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var flipsHorizontallyInOppositeLayoutDirection: Swift.Bool {
    @objc get
  }
  @_Concurrency.MainActor @preconcurrency @objc override required dynamic public init()
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func prepare()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func invalidateLayout()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func invalidateLayout(with context: UIKit.UICollectionViewLayoutInvalidationContext)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func invalidationContext(forPreferredLayoutAttributes _: UIKit.UICollectionViewLayoutAttributes, withOriginalAttributes _: UIKit.UICollectionViewLayoutAttributes) -> UIKit.UICollectionViewLayoutInvalidationContext
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func shouldInvalidateLayout(forPreferredLayoutAttributes preferredAttributes: UIKit.UICollectionViewLayoutAttributes, withOriginalAttributes originalAttributes: UIKit.UICollectionViewLayoutAttributes) -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func layoutAttributesForItem(at indexPath: Foundation.IndexPath) -> UIKit.UICollectionViewLayoutAttributes?
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func layoutAttributesForDecorationView(ofKind elementKind: Swift.String, at indexPath: Foundation.IndexPath) -> UIKit.UICollectionViewLayoutAttributes?
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func layoutAttributesForElements(in _: CoreFoundation.CGRect) -> [UIKit.UICollectionViewLayoutAttributes]?
  @objc deinit
}
public enum PagingContentInteraction {
  case scrolling
  case none
  public static func == (a: NECommonUIKit.PagingContentInteraction, b: NECommonUIKit.PagingContentInteraction) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol NEPagingContentViewControllerDelegate : AnyObject {
  func contentViewController(viewController: NECommonUIKit.NEPagingContentViewController, willBeginManualScrollOn index: Swift.Int)
  func contentViewController(viewController: NECommonUIKit.NEPagingContentViewController, didManualScrollOn index: Swift.Int, percent: CoreFoundation.CGFloat)
  func contentViewController(viewController: NECommonUIKit.NEPagingContentViewController, didEndManualScrollOn index: Swift.Int)
  func contentViewController(viewController: NECommonUIKit.NEPagingContentViewController, willBeginPagingAt index: Swift.Int, animated: Swift.Bool)
  func contentViewController(viewController: NECommonUIKit.NEPagingContentViewController, willFinishPagingAt index: Swift.Int, animated: Swift.Bool)
  func contentViewController(viewController: NECommonUIKit.NEPagingContentViewController, didFinishPagingAt index: Swift.Int, animated: Swift.Bool)
}
extension NECommonUIKit.NEPagingContentViewControllerDelegate {
  public func contentViewController(viewController: NECommonUIKit.NEPagingContentViewController, willBeginManualScrollOn index: Swift.Int)
  public func contentViewController(viewController: NECommonUIKit.NEPagingContentViewController, didManualScrollOn index: Swift.Int, percent: CoreFoundation.CGFloat)
  public func contentViewController(viewController: NECommonUIKit.NEPagingContentViewController, didEndManualScrollOn index: Swift.Int)
  public func contentViewController(viewController: NECommonUIKit.NEPagingContentViewController, willBeginPagingAt index: Swift.Int, animated: Swift.Bool)
  public func contentViewController(viewController: NECommonUIKit.NEPagingContentViewController, willFinishPagingAt index: Swift.Int, animated: Swift.Bool)
  public func contentViewController(viewController: NECommonUIKit.NEPagingContentViewController, didFinishPagingAt index: Swift.Int, animated: Swift.Bool)
}
public protocol NEPagingContentViewControllerDataSource : AnyObject {
  func numberOfItemsForContentViewController(viewController: NECommonUIKit.NEPagingContentViewController) -> Swift.Int
  func contentViewController(viewController: NECommonUIKit.NEPagingContentViewController, viewControllerAt index: Swift.Int) -> UIKit.UIViewController
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency public class NEPagingContentViewController : UIKit.UIViewController {
  @_Concurrency.MainActor @preconcurrency weak public var delegate: (any NECommonUIKit.NEPagingContentViewControllerDelegate)?
  @_Concurrency.MainActor @preconcurrency weak public var dataSource: (any NECommonUIKit.NEPagingContentViewControllerDataSource)?
  @_Concurrency.MainActor @preconcurrency public var isEnabledPreloadContent: Swift.Bool
  @_Concurrency.MainActor @preconcurrency public var contentOffsetRatio: CoreFoundation.CGFloat {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var currentPageIndex: Swift.Int {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var currentPagingPercent: CoreFoundation.CGFloat {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var adjucentPageIndex: Swift.Int {
    get
  }
  @_Concurrency.MainActor @preconcurrency public func reloadData(with page: Swift.Int? = nil, completion: (() -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency public func scroll(to page: Swift.Int, animated: Swift.Bool, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency final public let scrollView: UIKit.UIScrollView
  @_Concurrency.MainActor @preconcurrency public func preloadContentIfNeeded(with scrollingPercent: CoreFoundation.CGFloat)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewWillAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewWillDisappear(_ animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidDisappear(_ animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidLayoutSubviews()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func didReceiveMemoryWarning()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewWillTransition(to size: CoreFoundation.CGSize, with coordinator: any UIKit.UIViewControllerTransitionCoordinator)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public var shouldAutomaticallyForwardAppearanceMethods: Swift.Bool {
    @objc get
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
extension NECommonUIKit.NEPagingContentViewController : UIKit.UIScrollViewDelegate {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func scrollViewWillBeginDragging(_ scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func scrollViewDidScroll(_ scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func scrollViewWillBeginDecelerating(_ scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func scrollViewDidEndDecelerating(_ scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func scrollViewDidEndDragging(_ scrollView: UIKit.UIScrollView, willDecelerate decelerate: Swift.Bool)
}
public enum PagingDirection : Swift.Equatable {
  case reverse(sibling: Swift.Bool)
  case forward(sibling: Swift.Bool)
  case none
  public static func == (a: NECommonUIKit.PagingDirection, b: NECommonUIKit.PagingDirection) -> Swift.Bool
}
public struct NEPagingIndexItem : NECommonUIKit.NEPagingItem, Swift.Hashable, Swift.Comparable {
  public let index: Swift.Int
  public let title: Swift.String
  public init(index: Swift.Int, title: Swift.String)
  public static func < (lhs: NECommonUIKit.NEPagingIndexItem, rhs: NECommonUIKit.NEPagingIndexItem) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: NECommonUIKit.NEPagingIndexItem, b: NECommonUIKit.NEPagingIndexItem) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency open class NEPagingIndicatorLayoutAttributes : UIKit.UICollectionViewLayoutAttributes {
  @_Concurrency.MainActor @preconcurrency open var backgroundColor: UIKit.UIColor?
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func copy(with zone: ObjectiveC.NSZone? = nil) -> Any
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func isEqual(_ object: Any?) -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init()
  @objc deinit
}
public enum NEPagingIndicatorOptions {
  case hidden
  case visible(height: CoreFoundation.CGFloat, zIndex: Swift.Int, spacing: UIKit.UIEdgeInsets, insets: UIKit.UIEdgeInsets)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency open class NEPagingIndicatorView : UIKit.UICollectionReusableView {
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func apply(_ layoutAttributes: UIKit.UICollectionViewLayoutAttributes)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency open class NEPagingInvalidationContext : UIKit.UICollectionViewLayoutInvalidationContext {
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init()
  @objc deinit
}
public protocol NEPagingItem {
  var identifier: Swift.Int { get }
  func isEqual(to item: any NECommonUIKit.NEPagingItem) -> Swift.Bool
  func isBefore(item: any NECommonUIKit.NEPagingItem) -> Swift.Bool
}
extension NECommonUIKit.NEPagingItem where Self : Swift.Equatable {
  public func isEqual(to item: any NECommonUIKit.NEPagingItem) -> Swift.Bool
}
extension NECommonUIKit.NEPagingItem where Self : Swift.Comparable {
  public func isBefore(item: any NECommonUIKit.NEPagingItem) -> Swift.Bool
}
extension NECommonUIKit.NEPagingItem where Self : Swift.Hashable {
  public var identifier: Swift.Int {
    get
  }
}
public struct NEPagingItems {
  public let items: [any NECommonUIKit.NEPagingItem]
  public init(items: [any NECommonUIKit.NEPagingItem], hasItemsBefore: Swift.Bool = false, hasItemsAfter: Swift.Bool = false)
  public func indexPath(for pagingItem: any NECommonUIKit.NEPagingItem) -> Foundation.IndexPath?
  public func pagingItem(for indexPath: Foundation.IndexPath) -> any NECommonUIKit.NEPagingItem
  public func direction(from: any NECommonUIKit.NEPagingItem, to: any NECommonUIKit.NEPagingItem) -> NECommonUIKit.PagingDirection
}
@_hasMissingDesignatedInitializers public class NEPagingKitConfig {
  public static var focusColor: UIKit.UIColor
  public static var normalColor: UIKit.UIColor
  public static var menuTitleFont: UIKit.UIFont
  @objc deinit
}
public struct NEPagingKitProxy<Base> {
  public init(_ base: Base)
}
extension ObjectiveC.NSObjectProtocol {
  public static var pk: NECommonUIKit.NEPagingKitProxy<Self.Type> {
    get
  }
  public var pk: NECommonUIKit.NEPagingKitProxy<Self> {
    get
  }
}
extension NECommonUIKit.NEPagingKitProxy where Base == UIKit.UIColor.Type {
  public var focusRed: UIKit.UIColor {
    get
  }
}
public protocol NEPagingMenuDataSource : AnyObject {
  func pagingItemBefore(pagingItem: any NECommonUIKit.NEPagingItem) -> (any NECommonUIKit.NEPagingItem)?
  func pagingItemAfter(pagingItem: any NECommonUIKit.NEPagingItem) -> (any NECommonUIKit.NEPagingItem)?
}
public protocol NEPagingMenuDelegate : AnyObject {
  func selectContent(pagingItem: any NECommonUIKit.NEPagingItem, direction: NECommonUIKit.PagingDirection, animated: Swift.Bool)
  func removeContent()
}
public enum NEPagingMenuHorizontalAlignment {
  case left
  case center
  case right
  public static func == (a: NECommonUIKit.NEPagingMenuHorizontalAlignment, b: NECommonUIKit.NEPagingMenuHorizontalAlignment) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum PagingMenuInteraction {
  case scrolling
  case swipe
  case none
  public static func == (a: NECommonUIKit.PagingMenuInteraction, b: NECommonUIKit.PagingMenuInteraction) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum NEPagingMenuItemSize {
  case fixed(width: CoreFoundation.CGFloat, height: CoreFoundation.CGFloat)
  case selfSizing(estimatedWidth: CoreFoundation.CGFloat, height: CoreFoundation.CGFloat)
  case sizeToFit(minWidth: CoreFoundation.CGFloat, height: CoreFoundation.CGFloat)
}
extension NECommonUIKit.NEPagingMenuItemSize {
  public var width: CoreFoundation.CGFloat {
    get
  }
  public var height: CoreFoundation.CGFloat {
    get
  }
}
public enum NEPagingMenuItemSource {
  case `class`(type: NECommonUIKit.NEPagingCell.Type)
  case nib(nib: UIKit.UINib)
}
extension NECommonUIKit.NEPagingMenuItemSource : Swift.Equatable {
  public static func == (lhs: NECommonUIKit.NEPagingMenuItemSource, rhs: NECommonUIKit.NEPagingMenuItemSource) -> Swift.Bool
}
public enum NEPagingMenuPosition {
  case top
  case bottom
  public static func == (a: NECommonUIKit.NEPagingMenuPosition, b: NECommonUIKit.NEPagingMenuPosition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum NEPagingMenuTransition {
  case scrollAlongside
  case animateAfter
  public static func == (a: NECommonUIKit.NEPagingMenuTransition, b: NECommonUIKit.NEPagingMenuTransition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency open class NEPagingMenuView : UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency public var menuItemSpacing: CoreFoundation.CGFloat {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var menuItemLabelSpacing: CoreFoundation.CGFloat {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var menuItemSize: NECommonUIKit.NEPagingMenuItemSize {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var menuInsets: UIKit.UIEdgeInsets {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var menuHorizontalAlignment: NECommonUIKit.NEPagingMenuHorizontalAlignment {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var menuTransition: NECommonUIKit.NEPagingMenuTransition {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var menuInteraction: NECommonUIKit.PagingMenuInteraction {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var menuLayoutClass: NECommonUIKit.NEPagingCollectionViewLayout.Type {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var selectedScrollPosition: NECommonUIKit.NEPagingSelectedScrollPosition {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var indicatorOptions: NECommonUIKit.NEPagingIndicatorOptions {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var indicatorClass: NECommonUIKit.NEPagingIndicatorView.Type {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var indicatorColor: UIKit.UIColor {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var borderOptions: NECommonUIKit.NEPagingBorderOptions {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var borderClass: NECommonUIKit.NEPagingBorderView.Type {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var borderColor: UIKit.UIColor {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var includeSafeAreaInsets: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var font: UIKit.UIFont {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var selectedFont: UIKit.UIFont {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var textColor: UIKit.UIColor {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var selectedTextColor: UIKit.UIColor {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var backgroundColor: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency public var selectedBackgroundColor: UIKit.UIColor {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var menuBackgroundColor: UIKit.UIColor {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency weak public var delegate: (any NECommonUIKit.NEPagingMenuDelegate)? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency weak public var dataSource: (any NECommonUIKit.NEPagingMenuDataSource)? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var state: NECommonUIKit.NEPagingState {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var visibleItems: NECommonUIKit.NEPagingItems {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var collectionViewLayout: NECommonUIKit.NEPagingCollectionViewLayout {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var collectionView: UIKit.UICollectionView {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var options: NECommonUIKit.NEPagingOptions {
    get
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency open func viewAppeared()
  @_Concurrency.MainActor @preconcurrency open func transitionSize()
  @_Concurrency.MainActor @preconcurrency open func contentScrolled(progress: CoreFoundation.CGFloat)
  @_Concurrency.MainActor @preconcurrency open func contentFinishedScrolling()
  @_Concurrency.MainActor @preconcurrency open func reload(around pagingItem: any NECommonUIKit.NEPagingItem)
  @_Concurrency.MainActor @preconcurrency open func select(pagingItem: any NECommonUIKit.NEPagingItem, animated: Swift.Bool = false)
  @objc deinit
}
extension NECommonUIKit.NEPagingMenuView : UIKit.UICollectionViewDelegate {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func scrollViewDidScroll(_: UIKit.UIScrollView)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func collectionView(_: UIKit.UICollectionView, didSelectItemAt indexPath: Foundation.IndexPath)
}
public enum NEPagingNavigationOrientation {
  case vertical
  case horizontal
  public static func == (a: NECommonUIKit.NEPagingNavigationOrientation, b: NECommonUIKit.NEPagingNavigationOrientation) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct NEPagingOptions {
  public var menuItemSize: NECommonUIKit.NEPagingMenuItemSize
  public var menuItemSpacing: CoreFoundation.CGFloat
  public var menuItemLabelSpacing: CoreFoundation.CGFloat
  public var menuInsets: UIKit.UIEdgeInsets
  public var menuHorizontalAlignment: NECommonUIKit.NEPagingMenuHorizontalAlignment
  public var menuPosition: NECommonUIKit.NEPagingMenuPosition
  public var menuTransition: NECommonUIKit.NEPagingMenuTransition
  public var menuInteraction: NECommonUIKit.PagingMenuInteraction
  public var contentInteraction: NECommonUIKit.PagingContentInteraction
  public var menuLayoutClass: NECommonUIKit.NEPagingCollectionViewLayout.Type
  public var selectedScrollPosition: NECommonUIKit.NEPagingSelectedScrollPosition
  public var indicatorOptions: NECommonUIKit.NEPagingIndicatorOptions
  public var indicatorClass: NECommonUIKit.NEPagingIndicatorView.Type
  public var indicatorColor: UIKit.UIColor
  public var borderOptions: NECommonUIKit.NEPagingBorderOptions
  public var borderClass: NECommonUIKit.NEPagingBorderView.Type
  public var borderColor: UIKit.UIColor
  public var includeSafeAreaInsets: Swift.Bool
  public var font: UIKit.UIFont
  public var selectedFont: UIKit.UIFont
  public var textColor: UIKit.UIColor
  public var selectedTextColor: UIKit.UIColor
  public var backgroundColor: UIKit.UIColor
  public var selectedBackgroundColor: UIKit.UIColor
  public var menuBackgroundColor: UIKit.UIColor
  public var pagingContentBackgroundColor: UIKit.UIColor
  public var contentNavigationOrientation: NECommonUIKit.NEPagingNavigationOrientation
  public var scrollPosition: UIKit.UICollectionView.ScrollPosition {
    get
  }
  public var menuHeight: CoreFoundation.CGFloat {
    get
  }
  public var estimatedItemWidth: CoreFoundation.CGFloat {
    get
  }
  public init()
}
public enum NEPagingSelectedScrollPosition {
  case left
  case right
  case center
  case preferCentered
  public static func == (a: NECommonUIKit.NEPagingSelectedScrollPosition, b: NECommonUIKit.NEPagingSelectedScrollPosition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum NEPagingState : Swift.Equatable {
  case empty
  case selected(pagingItem: any NECommonUIKit.NEPagingItem)
  case scrolling(pagingItem: any NECommonUIKit.NEPagingItem, upcomingPagingItem: (any NECommonUIKit.NEPagingItem)?, progress: CoreFoundation.CGFloat, initialContentOffset: CoreFoundation.CGPoint, distance: CoreFoundation.CGFloat)
}
extension NECommonUIKit.NEPagingState {
  public var currentPagingItem: (any NECommonUIKit.NEPagingItem)? {
    get
  }
  public var upcomingPagingItem: (any NECommonUIKit.NEPagingItem)? {
    get
  }
  public var progress: CoreFoundation.CGFloat {
    get
  }
  public var distance: CoreFoundation.CGFloat {
    get
  }
  public var visuallySelectedPagingItem: (any NECommonUIKit.NEPagingItem)? {
    get
  }
}
public func == (lhs: NECommonUIKit.NEPagingState, rhs: NECommonUIKit.NEPagingState) -> Swift.Bool
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency open class NEPagingTitleCell : NECommonUIKit.NEPagingCell {
  @_Concurrency.MainActor @preconcurrency final public let titleLabel: UIKit.UILabel
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var isSelected: Swift.Bool {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency override open func setPagingItem(_ pagingItem: any NECommonUIKit.NEPagingItem, selected: Swift.Bool, options: NECommonUIKit.NEPagingOptions)
  @_Concurrency.MainActor @preconcurrency open func configure()
  @_Concurrency.MainActor @preconcurrency open func configureTitleLabel()
  @_Concurrency.MainActor @preconcurrency open func configureAccessibility()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func apply(_ layoutAttributes: UIKit.UICollectionViewLayoutAttributes)
  @objc deinit
}
@objc @_Concurrency.MainActor @preconcurrency open class NEPagingView : UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency final public let collectionView: UIKit.UICollectionView
  @_Concurrency.MainActor @preconcurrency final public let pageView: UIKit.UIView
  @_Concurrency.MainActor @preconcurrency public var options: NECommonUIKit.NEPagingOptions {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public init(options: NECommonUIKit.NEPagingOptions, collectionView: UIKit.UICollectionView, pageView: UIKit.UIView)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder _: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency open func configure()
  @_Concurrency.MainActor @preconcurrency open func setupConstraints()
  @objc deinit
}
@objc @objcMembers @_Concurrency.MainActor @preconcurrency open class NEPagingViewController : UIKit.UIViewController, UIKit.UICollectionViewDelegate, NECommonUIKit.NEPageViewControllerDataSource, NECommonUIKit.NEPageViewControllerDelegate {
  @_Concurrency.MainActor @preconcurrency public var menuItemSize: NECommonUIKit.NEPagingMenuItemSize {
    get
    set
  }
  @objc @_Concurrency.MainActor @preconcurrency public var menuItemSpacing: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency public var menuItemLabelSpacing: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency public var menuInsets: UIKit.UIEdgeInsets {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency public var menuHorizontalAlignment: NECommonUIKit.NEPagingMenuHorizontalAlignment {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var menuPosition: NECommonUIKit.NEPagingMenuPosition {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var menuTransition: NECommonUIKit.NEPagingMenuTransition {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var menuInteraction: NECommonUIKit.PagingMenuInteraction {
    get
    set
  }
  @objc @_Concurrency.MainActor @preconcurrency public var menuLayoutClass: NECommonUIKit.NEPagingCollectionViewLayout.Type {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency public var selectedScrollPosition: NECommonUIKit.NEPagingSelectedScrollPosition {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var indicatorOptions: NECommonUIKit.NEPagingIndicatorOptions {
    get
    set
  }
  @objc @_Concurrency.MainActor @preconcurrency public var indicatorClass: NECommonUIKit.NEPagingIndicatorView.Type {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency public var indicatorColor: UIKit.UIColor {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency public var borderOptions: NECommonUIKit.NEPagingBorderOptions {
    get
    set
  }
  @objc @_Concurrency.MainActor @preconcurrency public var borderClass: NECommonUIKit.NEPagingBorderView.Type {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency public var borderColor: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency public var includeSafeAreaInsets: Swift.Bool {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency public var font: UIKit.UIFont {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency public var selectedFont: UIKit.UIFont {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency public var textColor: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency public var selectedTextColor: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency public var backgroundColor: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency public var selectedBackgroundColor: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency public var menuBackgroundColor: UIKit.UIColor {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency public var contentNavigationOrientation: NECommonUIKit.NEPagingNavigationOrientation {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var contentInteraction: NECommonUIKit.PagingContentInteraction {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var state: NECommonUIKit.NEPagingState {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var visibleItems: NECommonUIKit.NEPagingItems {
    get
  }
  @_Concurrency.MainActor @preconcurrency weak public var dataSource: (any NECommonUIKit.NEPagingViewControllerDataSource)? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency weak public var infiniteDataSource: (any NECommonUIKit.NEPagingViewControllerInfiniteDataSource)?
  @_Concurrency.MainActor @preconcurrency weak public var delegate: (any NECommonUIKit.NEPagingViewControllerDelegate)?
  @_Concurrency.MainActor @preconcurrency weak public var sizeDelegate: (any NECommonUIKit.NEPagingViewControllerSizeDelegate)? {
    get
    set
  }
  @objc @_Concurrency.MainActor @preconcurrency public var collectionViewLayout: NECommonUIKit.NEPagingCollectionViewLayout {
    get
  }
  @objc @_Concurrency.MainActor @preconcurrency final public let collectionView: UIKit.UICollectionView
  @objc @_Concurrency.MainActor @preconcurrency final public let pageViewController: NECommonUIKit.NEPageViewController
  @_Concurrency.MainActor @preconcurrency public var options: NECommonUIKit.NEPagingOptions {
    get
  }
  @_Concurrency.MainActor @preconcurrency public init(options: NECommonUIKit.NEPagingOptions = NEPagingOptions())
  @_Concurrency.MainActor @preconcurrency convenience public init(options: NECommonUIKit.NEPagingOptions = NEPagingOptions(), viewControllers: [UIKit.UIViewController])
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc @_Concurrency.MainActor @preconcurrency open func reloadMenu()
  @objc @_Concurrency.MainActor @preconcurrency open func reloadData()
  @_Concurrency.MainActor @preconcurrency open func reloadData(around pagingItem: any NECommonUIKit.NEPagingItem)
  @_Concurrency.MainActor @preconcurrency open func select(pagingItem: any NECommonUIKit.NEPagingItem, animated: Swift.Bool = false)
  @objc @_Concurrency.MainActor @preconcurrency open func select(index: Swift.Int, animated: Swift.Bool = false)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func loadView()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func viewDidLoad()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func viewDidLayoutSubviews()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func viewWillTransition(to size: CoreFoundation.CGSize, with coordinator: any UIKit.UIViewControllerTransitionCoordinator)
  @_Concurrency.MainActor @preconcurrency public func register(_ cellClass: Swift.AnyClass?, for pagingItemType: any NECommonUIKit.NEPagingItem.Type)
  @_Concurrency.MainActor @preconcurrency public func register(_ nib: UIKit.UINib?, for pagingItemType: any NECommonUIKit.NEPagingItem.Type)
  @_Concurrency.MainActor @preconcurrency @objc open func scrollViewDidScroll(_: UIKit.UIScrollView)
  @_Concurrency.MainActor @preconcurrency @objc open func scrollViewWillBeginDragging(_: UIKit.UIScrollView)
  @_Concurrency.MainActor @preconcurrency @objc open func scrollViewWillEndDragging(_: UIKit.UIScrollView, withVelocity _: CoreFoundation.CGPoint, targetContentOffset _: Swift.UnsafeMutablePointer<CoreFoundation.CGPoint>)
  @_Concurrency.MainActor @preconcurrency @objc open func scrollViewDidEndDragging(_: UIKit.UIScrollView, willDecelerate _: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc open func scrollViewDidEndScrollingAnimation(_: UIKit.UIScrollView)
  @_Concurrency.MainActor @preconcurrency @objc open func scrollViewWillBeginDecelerating(_: UIKit.UIScrollView)
  @_Concurrency.MainActor @preconcurrency @objc open func scrollViewDidEndDecelerating(_: UIKit.UIScrollView)
  @_Concurrency.MainActor @preconcurrency @objc open func collectionView(_: UIKit.UICollectionView, didSelectItemAt indexPath: Foundation.IndexPath)
  @_Concurrency.MainActor @preconcurrency @objc open func collectionView(_: UIKit.UICollectionView, targetContentOffsetForProposedContentOffset proposedContentOffset: CoreFoundation.CGPoint) -> CoreFoundation.CGPoint
  @_Concurrency.MainActor @preconcurrency @objc open func collectionView(_: UIKit.UICollectionView, didUnhighlightItemAt _: Foundation.IndexPath)
  @_Concurrency.MainActor @preconcurrency @objc open func collectionView(_: UIKit.UICollectionView, didHighlightItemAt _: Foundation.IndexPath)
  @_Concurrency.MainActor @preconcurrency @objc open func collectionView(_: UIKit.UICollectionView, didDeselectItemAt _: Foundation.IndexPath)
  @_Concurrency.MainActor @preconcurrency @objc open func collectionView(_: UIKit.UICollectionView, willDisplay _: UIKit.UICollectionViewCell, forItemAt _: Foundation.IndexPath)
  @_Concurrency.MainActor @preconcurrency @objc open func collectionView(_: UIKit.UICollectionView, didEndDisplaying _: UIKit.UICollectionViewCell, forItemAt _: Foundation.IndexPath)
  @objc @_Concurrency.MainActor @preconcurrency open func pageViewController(_: NECommonUIKit.NEPageViewController, viewControllerBeforeViewController _: UIKit.UIViewController) -> UIKit.UIViewController?
  @objc @_Concurrency.MainActor @preconcurrency open func pageViewController(_: NECommonUIKit.NEPageViewController, viewControllerAfterViewController _: UIKit.UIViewController) -> UIKit.UIViewController?
  @objc @_Concurrency.MainActor @preconcurrency open func pageViewController(_: NECommonUIKit.NEPageViewController, isScrollingFrom startingViewController: UIKit.UIViewController, destinationViewController: UIKit.UIViewController?, progress: CoreFoundation.CGFloat)
  @objc @_Concurrency.MainActor @preconcurrency open func pageViewController(_: NECommonUIKit.NEPageViewController, willStartScrollingFrom startingViewController: UIKit.UIViewController, destinationViewController: UIKit.UIViewController)
  @objc @_Concurrency.MainActor @preconcurrency open func pageViewController(_: NECommonUIKit.NEPageViewController, didFinishScrollingFrom startingViewController: UIKit.UIViewController, destinationViewController: UIKit.UIViewController, transitionSuccessful: Swift.Bool)
  @objc deinit
}
extension NECommonUIKit.NEPagingViewController : NECommonUIKit.NEPagingMenuDataSource {
  @_Concurrency.MainActor @preconcurrency public func pagingItemBefore(pagingItem: any NECommonUIKit.NEPagingItem) -> (any NECommonUIKit.NEPagingItem)?
  @_Concurrency.MainActor @preconcurrency public func pagingItemAfter(pagingItem: any NECommonUIKit.NEPagingItem) -> (any NECommonUIKit.NEPagingItem)?
}
extension NECommonUIKit.NEPagingViewController : NECommonUIKit.NEPagingMenuDelegate {
  @_Concurrency.MainActor @preconcurrency public func selectContent(pagingItem: any NECommonUIKit.NEPagingItem, direction: NECommonUIKit.PagingDirection, animated: Swift.Bool)
  @objc @_Concurrency.MainActor @preconcurrency dynamic public func removeContent()
}
public protocol NEPagingViewControllerDataSource : AnyObject {
  func numberOfViewControllers(in pagingViewController: NECommonUIKit.NEPagingViewController) -> Swift.Int
  func pagingViewController(_: NECommonUIKit.NEPagingViewController, viewControllerAt index: Swift.Int) -> UIKit.UIViewController
  func pagingViewController(_: NECommonUIKit.NEPagingViewController, pagingItemAt index: Swift.Int) -> any NECommonUIKit.NEPagingItem
}
public protocol NEPagingViewControllerDelegate : AnyObject {
  func pagingViewController(_: NECommonUIKit.NEPagingViewController, isScrollingFromItem currentPagingItem: any NECommonUIKit.NEPagingItem, toItem upcomingPagingItem: (any NECommonUIKit.NEPagingItem)?, startingViewController: UIKit.UIViewController, destinationViewController: UIKit.UIViewController?, progress: CoreFoundation.CGFloat)
  func pagingViewController(_: NECommonUIKit.NEPagingViewController, willScrollToItem pagingItem: any NECommonUIKit.NEPagingItem, startingViewController: UIKit.UIViewController, destinationViewController: UIKit.UIViewController)
  func pagingViewController(_ pagingViewController: NECommonUIKit.NEPagingViewController, didScrollToItem pagingItem: any NECommonUIKit.NEPagingItem, startingViewController: UIKit.UIViewController?, destinationViewController: UIKit.UIViewController, transitionSuccessful: Swift.Bool)
  func pagingViewController(_ pagingViewController: NECommonUIKit.NEPagingViewController, didSelectItem pagingItem: any NECommonUIKit.NEPagingItem)
}
public protocol NEPagingViewControllerInfiniteDataSource : AnyObject {
  func pagingViewController(_: NECommonUIKit.NEPagingViewController, viewControllerFor pagingItem: any NECommonUIKit.NEPagingItem) -> UIKit.UIViewController
  func pagingViewController(_: NECommonUIKit.NEPagingViewController, itemBefore pagingItem: any NECommonUIKit.NEPagingItem) -> (any NECommonUIKit.NEPagingItem)?
  func pagingViewController(_: NECommonUIKit.NEPagingViewController, itemAfter pagingItem: any NECommonUIKit.NEPagingItem) -> (any NECommonUIKit.NEPagingItem)?
}
public protocol NEPagingViewControllerSizeDelegate : AnyObject {
  func pagingViewController(_: NECommonUIKit.NEPagingViewController, widthForPagingItem pagingItem: any NECommonUIKit.NEPagingItem, isSelected: Swift.Bool) -> CoreFoundation.CGFloat
}
final public class NEPointValueProvider {
  public init(block: @escaping NECommonUIKit.NEPointValueProvider.PointValueBlock)
  public init(_ point: CoreFoundation.CGPoint)
  public typealias PointValueBlock = (CoreFoundation.CGFloat) -> CoreFoundation.CGPoint
  final public var point: CoreFoundation.CGPoint {
    get
    set
  }
  final public var valueType: any Any.Type {
    get
  }
  final public var storage: NECommonUIKit.NEValueProviderStorage<NECommonUIKit.NELottieVector3D> {
    get
  }
  final public func hasUpdate(frame _: CoreFoundation.CGFloat) -> Swift.Bool
  @objc deinit
}
extension NECommonUIKit.NEPointValueProvider : Swift.Equatable {
  public static func == (lhs: NECommonUIKit.NEPointValueProvider, rhs: NECommonUIKit.NEPointValueProvider) -> Swift.Bool
}
@_inheritsConvenienceInitializers @available(iOSApplicationExtension, unavailable)
@objc @_Concurrency.MainActor @preconcurrency open class NEPreviousNextView : UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
public enum NEReducedMotionOption {
  case specific(NECommonUIKit.NEReducedMotionMode)
  case dynamic(any NECommonUIKit.NEReducedMotionOptionProvider, dataID: Swift.AnyHashable)
}
extension NECommonUIKit.NEReducedMotionOption {
  public static var standardMotion: NECommonUIKit.NEReducedMotionOption {
    get
  }
  public static var reducedMotion: NECommonUIKit.NEReducedMotionOption {
    get
  }
  public static var systemReducedMotionToggle: NECommonUIKit.NEReducedMotionOption {
    get
  }
}
extension NECommonUIKit.NEReducedMotionOption {
  public var currentReducedMotionMode: NECommonUIKit.NEReducedMotionMode {
    get
  }
}
extension NECommonUIKit.NEReducedMotionOption : Swift.Hashable {
  public static func == (lhs: NECommonUIKit.NEReducedMotionOption, rhs: NECommonUIKit.NEReducedMotionOption) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum NEReducedMotionMode : Swift.Hashable {
  case standardMotion
  case reducedMotion
  public static func == (a: NECommonUIKit.NEReducedMotionMode, b: NECommonUIKit.NEReducedMotionMode) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol NEReducedMotionOptionProvider {
  var currentReducedMotionMode: NECommonUIKit.NEReducedMotionMode { get }
}
public struct NESystemReducedMotionOptionProvider : NECommonUIKit.NEReducedMotionOptionProvider {
  public init()
  public var currentReducedMotionMode: NECommonUIKit.NEReducedMotionMode {
    get
  }
}
public enum NERenderingEngineOption : Swift.Hashable {
  case automatic
  case specific(NECommonUIKit.NERenderingEngine)
  public static var mainThread: NECommonUIKit.NERenderingEngineOption {
    get
  }
  public static var coreAnimation: NECommonUIKit.NERenderingEngineOption {
    get
  }
}
public enum NERenderingEngine : Swift.Hashable {
  case mainThread
  case coreAnimation
}
extension NECommonUIKit.NERenderingEngineOption : Swift.RawRepresentable, Swift.CustomStringConvertible {
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
  public var description: Swift.String {
    get
  }
  public typealias RawValue = Swift.String
}
extension NECommonUIKit.NERenderingEngine : Swift.RawRepresentable, Swift.CustomStringConvertible {
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
  public var description: Swift.String {
    get
  }
  public typealias RawValue = Swift.String
}
final public class NESizeValueProvider {
  public init(block: @escaping NECommonUIKit.NESizeValueProvider.SizeValueBlock)
  public init(_ size: CoreFoundation.CGSize)
  public typealias SizeValueBlock = (CoreFoundation.CGFloat) -> CoreFoundation.CGSize
  final public var size: CoreFoundation.CGSize {
    get
    set
  }
  final public var valueType: any Any.Type {
    get
  }
  final public var storage: NECommonUIKit.NEValueProviderStorage<NECommonUIKit.NELottieVector3D> {
    get
  }
  final public func hasUpdate(frame _: CoreFoundation.CGFloat) -> Swift.Bool
  @objc deinit
}
extension NECommonUIKit.NESizeValueProvider : Swift.Equatable {
  public static func == (lhs: NECommonUIKit.NESizeValueProvider, rhs: NECommonUIKit.NESizeValueProvider) -> Swift.Bool
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency open class NEPagingMenuViewCell : UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency open var isSelected: Swift.Bool
  @_Concurrency.MainActor @preconcurrency public var identifier: Swift.String! {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var index: Swift.Int! {
    get
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
open class PagingMenuFocusViewAnimationCoordinator {
  final public let beginFrame: CoreFoundation.CGRect
  final public let endFrame: CoreFoundation.CGRect
  public init(beginFrame: CoreFoundation.CGRect, endFrame: CoreFoundation.CGRect)
  open func animateFocusView(alongside animation: @escaping (NECommonUIKit.PagingMenuFocusViewAnimationCoordinator) -> Swift.Void, completion: ((Swift.Bool) -> Swift.Void)?)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency open class PagingMenuFocusView : UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency open var selectedIndex: Swift.Int?
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
}
public protocol PagingMenuViewDataSource : AnyObject {
  func numberOfItemForPagingMenuView() -> Swift.Int
  func pagingMenuView(pagingMenuView: NECommonUIKit.NETabPagingMenuView, cellForItemAt index: Swift.Int) -> NECommonUIKit.NEPagingMenuViewCell
  func pagingMenuView(pagingMenuView: NECommonUIKit.NETabPagingMenuView, widthForItemAt index: Swift.Int) -> CoreFoundation.CGFloat
}
public protocol PagingMenuViewDelegate : AnyObject {
  func pagingMenuView(pagingMenuView: NECommonUIKit.NETabPagingMenuView, didSelectItemAt index: Swift.Int)
  func pagingMenuView(pagingMenuView: NECommonUIKit.NETabPagingMenuView, willAnimateFocusViewTo index: Swift.Int, with coordinator: NECommonUIKit.PagingMenuFocusViewAnimationCoordinator)
  func pagingMenuView(pagingMenuView: NECommonUIKit.NETabPagingMenuView, willDisplay cell: NECommonUIKit.NEPagingMenuViewCell, forItemAt index: Swift.Int)
}
extension NECommonUIKit.PagingMenuViewDelegate {
  public func pagingMenuView(pagingMenuView: NECommonUIKit.NETabPagingMenuView, didSelectItemAt index: Swift.Int)
  public func pagingMenuView(pagingMenuView: NECommonUIKit.NETabPagingMenuView, willAnimateFocusViewTo index: Swift.Int, with coordinator: NECommonUIKit.PagingMenuFocusViewAnimationCoordinator)
  public func pagingMenuView(pagingMenuView: NECommonUIKit.NETabPagingMenuView, willDisplay cell: NECommonUIKit.NEPagingMenuViewCell, forItemAt index: Swift.Int)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency open class NETabPagingMenuView : UIKit.UIScrollView {
  public enum Alignment {
    case center
    case left
    case right
    public static func == (a: NECommonUIKit.NETabPagingMenuView.Alignment, b: NECommonUIKit.NETabPagingMenuView.Alignment) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_Concurrency.MainActor @preconcurrency final public let focusView: NECommonUIKit.PagingMenuFocusView
  @_Concurrency.MainActor @preconcurrency open var visibleCells: [NECommonUIKit.NEPagingMenuViewCell] {
    get
  }
  @_Concurrency.MainActor @preconcurrency open var cellAlignment: NECommonUIKit.NETabPagingMenuView.Alignment
  @_Concurrency.MainActor @preconcurrency open var cellSpacing: CoreFoundation.CGFloat
  @_Concurrency.MainActor @preconcurrency open var totalSpacing: CoreFoundation.CGFloat {
    get
  }
  @_Concurrency.MainActor @preconcurrency weak open var dataSource: (any NECommonUIKit.PagingMenuViewDataSource)?
  @_Concurrency.MainActor @preconcurrency weak open var menuDelegate: (any NECommonUIKit.PagingMenuViewDelegate)?
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency open var numberOfItem: Swift.Int
  @_Concurrency.MainActor @preconcurrency open func indexForItem(at point: CoreFoundation.CGPoint) -> Swift.Int?
  @_Concurrency.MainActor @preconcurrency open func cellForItem(at index: Swift.Int) -> NECommonUIKit.NEPagingMenuViewCell?
  @_Concurrency.MainActor @preconcurrency open func reloadData(with index: Swift.Int = 0, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency open func register(nib: UIKit.UINib?, with identifier: Swift.String)
  @_Concurrency.MainActor @preconcurrency open func register(type: NECommonUIKit.NEPagingMenuViewCell.Type, with identifier: Swift.String)
  @_Concurrency.MainActor @preconcurrency open func registerFocusView(view: UIKit.UIView, isBehindCell: Swift.Bool = false)
  @_Concurrency.MainActor @preconcurrency open func registerFocusView(nib: UIKit.UINib, isBehindCell: Swift.Bool = false)
  @_Concurrency.MainActor @preconcurrency open func dequeue(with identifier: Swift.String) -> NECommonUIKit.NEPagingMenuViewCell
  @_Concurrency.MainActor @preconcurrency open func rectForItem(at index: Swift.Int) -> CoreFoundation.CGRect
  @_Concurrency.MainActor @preconcurrency open func invalidateLayout()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func observeValue(forKeyPath keyPath: Swift.String?, of object: Any?, change: [Foundation.NSKeyValueChangeKey : Any]?, context: Swift.UnsafeMutableRawPointer?)
  @_Concurrency.MainActor @preconcurrency open func scroll(index: Swift.Int, percent: CoreFoundation.CGFloat = 0)
  @_Concurrency.MainActor @preconcurrency open func scroll(index: Swift.Int, completeHandler: @escaping (Swift.Bool) -> Swift.Void)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func layoutSubviews()
  @available(iOS 11.0, *)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func safeAreaInsetsDidChange()
  @objc deinit
}
extension NECommonUIKit.NETabPagingMenuView {
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func touchesBegan(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func touchesEnded(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func touchesCancelled(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
}
public protocol NETabPagingMenuViewControllerDelegate : AnyObject {
  func menuViewController(viewController: NECommonUIKit.NETabPagingMenuViewController, focusViewDidEndTransition focusView: NECommonUIKit.PagingMenuFocusView)
  func menuViewController(viewController: NECommonUIKit.NETabPagingMenuViewController, didSelect page: Swift.Int, previousPage: Swift.Int)
  func menuViewController(viewController: NECommonUIKit.NETabPagingMenuViewController, willAnimateFocusViewTo index: Swift.Int, with coordinator: NECommonUIKit.PagingMenuFocusViewAnimationCoordinator)
  func menuViewController(viewController: NECommonUIKit.NETabPagingMenuViewController, willDisplay cell: NECommonUIKit.NEPagingMenuViewCell, forItemAt index: Swift.Int)
}
extension NECommonUIKit.NETabPagingMenuViewControllerDelegate {
  public func menuViewController(viewController: NECommonUIKit.NETabPagingMenuViewController, focusViewDidEndTransition focusView: NECommonUIKit.PagingMenuFocusView)
  public func menuViewController(viewController: NECommonUIKit.NETabPagingMenuViewController, willAnimateFocusViewTo index: Swift.Int, with coordinator: NECommonUIKit.PagingMenuFocusViewAnimationCoordinator)
  public func menuViewController(viewController: NECommonUIKit.NETabPagingMenuViewController, willDisplay cell: NECommonUIKit.NEPagingMenuViewCell, forItemAt index: Swift.Int)
}
public protocol NETabPagingMenuViewControllerDataSource : AnyObject {
  func numberOfItemsForMenuViewController(viewController: NECommonUIKit.NETabPagingMenuViewController) -> Swift.Int
  func menuViewController(viewController: NECommonUIKit.NETabPagingMenuViewController, cellForItemAt index: Swift.Int) -> NECommonUIKit.NEPagingMenuViewCell
  func menuViewController(viewController: NECommonUIKit.NETabPagingMenuViewController, widthForItemAt index: Swift.Int) -> CoreFoundation.CGFloat
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency public class NETabPagingMenuViewController : UIKit.UIViewController {
  @_Concurrency.MainActor @preconcurrency weak public var delegate: (any NECommonUIKit.NETabPagingMenuViewControllerDelegate)?
  @_Concurrency.MainActor @preconcurrency weak public var dataSource: (any NECommonUIKit.NETabPagingMenuViewControllerDataSource)?
  @_Concurrency.MainActor @preconcurrency final public let menuView: NECommonUIKit.NETabPagingMenuView
  @_Concurrency.MainActor @preconcurrency public var focusView: NECommonUIKit.PagingMenuFocusView {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var focusPointerOffset: CoreFoundation.CGPoint {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var percentOffset: CoreFoundation.CGFloat {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var cellAlignment: NECommonUIKit.NETabPagingMenuView.Alignment {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var cellSpacing: CoreFoundation.CGFloat {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var contentInset: UIKit.UIEdgeInsets {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public func scroll(index: Swift.Int, percent: CoreFoundation.CGFloat = 0, animated: Swift.Bool = true)
  @_Concurrency.MainActor @preconcurrency public var visibleCells: [NECommonUIKit.NEPagingMenuViewCell] {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var currentFocusedCell: NECommonUIKit.NEPagingMenuViewCell? {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var currentFocusedIndex: Swift.Int? {
    get
  }
  @_Concurrency.MainActor @preconcurrency public func cellForItem(at index: Swift.Int) -> NECommonUIKit.NEPagingMenuViewCell?
  @_Concurrency.MainActor @preconcurrency public func registerFocusView(view: UIKit.UIView, isBehindCell: Swift.Bool = false)
  @_Concurrency.MainActor @preconcurrency public func registerFocusView(nib: UIKit.UINib, isBehindCell: Swift.Bool = false)
  @_Concurrency.MainActor @preconcurrency public func register(nib: UIKit.UINib?, forCellWithReuseIdentifier identifier: Swift.String)
  @_Concurrency.MainActor @preconcurrency public func register(type: NECommonUIKit.NEPagingMenuViewCell.Type, forCellWithReuseIdentifier identifier: Swift.String)
  @_Concurrency.MainActor @preconcurrency public func dequeueReusableCell(withReuseIdentifier identifier: Swift.String, for index: Swift.Int) -> NECommonUIKit.NEPagingMenuViewCell
  @_Concurrency.MainActor @preconcurrency public func reloadData(with preferredFocusIndex: Swift.Int? = nil, completionHandler: ((Swift.Bool) -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency public func invalidateLayout()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidLayoutSubviews()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func didReceiveMemoryWarning()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewWillTransition(to size: CoreFoundation.CGSize, with coordinator: any UIKit.UIViewControllerTransitionCoordinator)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
extension NECommonUIKit.NETabPagingMenuViewController : UIKit.UIScrollViewDelegate {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func scrollViewDidEndDecelerating(_ scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func scrollViewDidEndDragging(_ scrollView: UIKit.UIScrollView, willDecelerate decelerate: Swift.Bool)
}
extension NECommonUIKit.NETabPagingMenuViewController : NECommonUIKit.PagingMenuViewDelegate {
  @_Concurrency.MainActor @preconcurrency public func pagingMenuView(pagingMenuView: NECommonUIKit.NETabPagingMenuView, willDisplay cell: NECommonUIKit.NEPagingMenuViewCell, forItemAt index: Swift.Int)
  @_Concurrency.MainActor @preconcurrency public func pagingMenuView(pagingMenuView: NECommonUIKit.NETabPagingMenuView, willAnimateFocusViewTo index: Swift.Int, with coordinator: NECommonUIKit.PagingMenuFocusViewAnimationCoordinator)
  @_Concurrency.MainActor @preconcurrency public func pagingMenuView(pagingMenuView: NECommonUIKit.NETabPagingMenuView, didSelectItemAt index: Swift.Int)
}
extension NECommonUIKit.NETabPagingMenuViewController : NECommonUIKit.PagingMenuViewDataSource {
  @_Concurrency.MainActor @preconcurrency public func numberOfItemForPagingMenuView() -> Swift.Int
  @_Concurrency.MainActor @preconcurrency public func pagingMenuView(pagingMenuView: NECommonUIKit.NETabPagingMenuView, widthForItemAt index: Swift.Int) -> CoreFoundation.CGFloat
  @_Concurrency.MainActor @preconcurrency public func pagingMenuView(pagingMenuView: NECommonUIKit.NETabPagingMenuView, cellForItemAt index: Swift.Int) -> NECommonUIKit.NEPagingMenuViewCell
}
extension UIKit.UITextField {
  @_Concurrency.MainActor @preconcurrency public func removeAllAutoLayout()
}
@_inheritsConvenienceInitializers @available(iOSApplicationExtension, unavailable)
@objc @_Concurrency.MainActor @preconcurrency open class NETextView : UIKit.UITextView {
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect, textContainer: UIKit.NSTextContainer?)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func awakeFromNib()
  @objc deinit
  @_Concurrency.MainActor @preconcurrency public var placeholderLabel: UIKit.UILabel {
    get
    set
  }
  @objc @IBInspectable @_Concurrency.MainActor @preconcurrency open var placeholderTextColor: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor @preconcurrency open var placeholder: Swift.String? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency open var attributedPlaceholder: Foundation.NSAttributedString? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func layoutSubviews()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var text: Swift.String! {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var attributedText: Foundation.NSAttributedString! {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var font: UIKit.UIFont? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var textAlignment: UIKit.NSTextAlignment {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override weak dynamic open var delegate: (any UIKit.UITextViewDelegate)? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
  @_Concurrency.MainActor @preconcurrency public func removeAllAutoLayout()
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOSApplicationExtension, unavailable)
@_Concurrency.MainActor @preconcurrency open class NETitleBarButtonItem : NECommonUIKit.NEBarButtonItem {
  @objc @_Concurrency.MainActor @preconcurrency open var titleFont: UIKit.UIFont? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var title: Swift.String? {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency open var titleColor: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency open var selectableTitleColor: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override open var invocation: NECommonUIKit.NEInvocation? {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency convenience public init(title: Swift.String?)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency public class NETitleLabelMenuViewCell : NECommonUIKit.NEPagingMenuViewCell {
  @_Concurrency.MainActor @preconcurrency public var focusColor: UIKit.UIColor {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var normalColor: UIKit.UIColor {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var labelWidth: CoreFoundation.CGFloat {
    get
  }
  @_Concurrency.MainActor @preconcurrency final public let titleLabel: UIKit.UILabel
  @_Concurrency.MainActor @preconcurrency public func setImage(_ image: UIKit.UIImage?)
  @_Concurrency.MainActor @preconcurrency public var spacing: CoreFoundation.CGFloat {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public func calcIntermediateLabelSize(with currentCell: NECommonUIKit.NETitleLabelMenuViewCell, percent: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency override public var isSelected: Swift.Bool {
    get
    set
  }
  @objc deinit
}
extension UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency public func makeToast(_ message: Swift.String?, duration: Foundation.TimeInterval = NEToastManager.shared.duration, position: NECommonUIKit.ToastPosition = NEToastManager.shared.position, title: Swift.String? = nil, image: UIKit.UIImage? = nil, style: NECommonUIKit.ToastStyle = NEToastManager.shared.style, completion: ((_ didTap: Swift.Bool) -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency public func makeToast(_ message: Swift.String?, duration: Foundation.TimeInterval = NEToastManager.shared.duration, point: CoreFoundation.CGPoint, title: Swift.String?, image: UIKit.UIImage?, style: NECommonUIKit.ToastStyle = NEToastManager.shared.style, completion: ((_ didTap: Swift.Bool) -> Swift.Void)?)
  @_Concurrency.MainActor @preconcurrency public func showToast(_ toast: UIKit.UIView, duration: Foundation.TimeInterval = NEToastManager.shared.duration, position: NECommonUIKit.ToastPosition = NEToastManager.shared.position, completion: ((_ didTap: Swift.Bool) -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency public func showToast(_ toast: UIKit.UIView, duration: Foundation.TimeInterval = NEToastManager.shared.duration, point: CoreFoundation.CGPoint, completion: ((_ didTap: Swift.Bool) -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency public func hideToast()
  @_Concurrency.MainActor @preconcurrency public func hideToast(_ toast: UIKit.UIView)
  @_Concurrency.MainActor @preconcurrency public func hideAllToasts(includeActivity: Swift.Bool = false, clearQueue: Swift.Bool = true)
  @_Concurrency.MainActor @preconcurrency public func clearToastQueue()
  @_Concurrency.MainActor @preconcurrency public func makeToastActivity(_ position: NECommonUIKit.ToastPosition)
  @_Concurrency.MainActor @preconcurrency public func makeToastActivity(_ point: CoreFoundation.CGPoint)
  @_Concurrency.MainActor @preconcurrency public func hideToastActivity()
  @_Concurrency.MainActor @preconcurrency public func toastViewForMessage(_ message: Swift.String?, title: Swift.String?, image: UIKit.UIImage?, style: NECommonUIKit.ToastStyle) throws -> UIKit.UIView
}
public struct ToastStyle {
  public init()
  public var backgroundColor: UIKit.UIColor
  public var titleColor: UIKit.UIColor
  public var messageColor: UIKit.UIColor
  public var maxWidthPercentage: CoreFoundation.CGFloat {
    get
    set
  }
  public var maxHeightPercentage: CoreFoundation.CGFloat {
    get
    set
  }
  public var horizontalPadding: CoreFoundation.CGFloat
  public var verticalPadding: CoreFoundation.CGFloat
  public var cornerRadius: CoreFoundation.CGFloat
  public var titleFont: UIKit.UIFont
  public var messageFont: UIKit.UIFont
  public var titleAlignment: UIKit.NSTextAlignment
  public var messageAlignment: UIKit.NSTextAlignment
  public var titleNumberOfLines: Swift.Int
  public var messageNumberOfLines: Swift.Int
  public var displayShadow: Swift.Bool
  public var shadowColor: UIKit.UIColor
  public var shadowOpacity: Swift.Float {
    get
    set
  }
  public var shadowRadius: CoreFoundation.CGFloat
  public var shadowOffset: CoreFoundation.CGSize
  public var imageSize: CoreFoundation.CGSize
  public var activitySize: CoreFoundation.CGSize
  public var fadeDuration: Swift.Double
  public var activityIndicatorColor: UIKit.UIColor
  public var activityBackgroundColor: UIKit.UIColor
}
@_hasMissingDesignatedInitializers public class NEToastManager {
  public static let shared: NECommonUIKit.NEToastManager
  public var style: NECommonUIKit.ToastStyle
  public var isTapToDismissEnabled: Swift.Bool
  public var isQueueEnabled: Swift.Bool
  public var duration: Swift.Double
  public var position: NECommonUIKit.ToastPosition
  @objc deinit
}
public enum ToastPosition {
  case top
  case center
  case bottom
  public static func == (a: NECommonUIKit.ToastPosition, b: NECommonUIKit.ToastPosition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOSApplicationExtension, unavailable)
@objc @_Concurrency.MainActor @preconcurrency open class NEToolbar : UIKit.UIToolbar, UIKit.UIInputViewAudioFeedback {
  @objc @_Concurrency.MainActor @preconcurrency open var previousBarButton: NECommonUIKit.NEBarButtonItem {
    @objc get
    @objc set(newValue)
  }
  @objc @_Concurrency.MainActor @preconcurrency open var nextBarButton: NECommonUIKit.NEBarButtonItem {
    @objc get
    @objc set(newValue)
  }
  @objc @_Concurrency.MainActor @preconcurrency open var titleBarButton: NECommonUIKit.NETitleBarButtonItem {
    @objc get
    @objc set(newValue)
  }
  @objc @_Concurrency.MainActor @preconcurrency open var doneBarButton: NECommonUIKit.NEBarButtonItem {
    @objc get
    @objc set(newValue)
  }
  @objc @_Concurrency.MainActor @preconcurrency open var fixedSpaceBarButton: NECommonUIKit.NEBarButtonItem {
    @objc get
    @objc set(newValue)
  }
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func sizeThatFits(_ size: CoreFoundation.CGSize) -> CoreFoundation.CGSize
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var tintColor: UIKit.UIColor! {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func layoutSubviews()
  @_Concurrency.MainActor @preconcurrency @objc open var enableInputClicksWhenVisible: Swift.Bool {
    @objc get
  }
  @objc deinit
}
extension UIKit.UIColor {
  public var lottieColorValue: NECommonUIKit.NELottieColor {
    get
  }
}
@available(iOSApplicationExtension, unavailable)
@objc extension UIKit.UIScrollView {
  @objc @_Concurrency.MainActor @preconcurrency dynamic public var neShouldIgnoreScrollingAdjustment: Swift.Bool {
    @objc get
    @objc set(newValue)
  }
  @objc @_Concurrency.MainActor @preconcurrency dynamic public var neShouldIgnoreContentInsetAdjustment: Swift.Bool {
    @objc get
    @objc set(newValue)
  }
  @objc @_Concurrency.MainActor @preconcurrency dynamic public var neShouldRestoreScrollViewContentOffset: Swift.Bool {
    @objc get
    @objc set(newValue)
  }
}
extension UIKit.UITableView {
  @_Concurrency.MainActor @preconcurrency public func reloadData(_ indexs: [Foundation.IndexPath], _ animation: UIKit.UITableView.RowAnimation = .none, _ completion: ((Swift.Bool) -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency public func deleteData(_ indexs: [Foundation.IndexPath], _ animation: UIKit.UITableView.RowAnimation = .none, _ completion: ((Swift.Bool) -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency public func insertData(_ indexs: [Foundation.IndexPath], _ animation: UIKit.UITableView.RowAnimation = .none, _ completion: ((Swift.Bool) -> Swift.Void)? = nil)
}
@available(iOSApplicationExtension, unavailable)
public let kNEUseDefaultKeyboardDistance: CoreFoundation.CGFloat
@available(iOSApplicationExtension, unavailable)
@objc extension UIKit.UIView {
  @objc @_Concurrency.MainActor @preconcurrency dynamic public var neKeyboardDistanceFromTextField: CoreFoundation.CGFloat {
    @objc get
    @objc set(newValue)
  }
  @objc @_Concurrency.MainActor @preconcurrency dynamic public var neIgnoreSwitchingByNextPrevious: Swift.Bool {
    @objc get
    @objc set(newValue)
  }
  @objc @_Concurrency.MainActor @preconcurrency dynamic public var neEnableMode: NECommonUIKit.NEEnableMode {
    @objc get
    @objc set(newValue)
  }
  @objc @_Concurrency.MainActor @preconcurrency dynamic public var neShouldResignOnTouchOutsideMode: NECommonUIKit.NEEnableMode {
    @objc get
    @objc set(newValue)
  }
}
@available(iOSApplicationExtension, unavailable)
@objc extension UIKit.UIView {
  @objc @_Concurrency.MainActor @preconcurrency dynamic public func neViewContainingController() -> UIKit.UIViewController?
  @objc @_Concurrency.MainActor @preconcurrency dynamic public func neTopMostController() -> UIKit.UIViewController?
  @objc @_Concurrency.MainActor @preconcurrency dynamic public func neParentContainerViewController() -> UIKit.UIViewController?
  @objc @_Concurrency.MainActor @preconcurrency dynamic public func neSuperviewOfClassType(_ classType: UIKit.UIView.Type, belowView: UIKit.UIView? = nil) -> UIKit.UIView?
}
@available(iOSApplicationExtension, unavailable)
@objc final public class NEBarButtonItemConfiguration : ObjectiveC.NSObject {
  @objc public init(barButtonSystemItem: UIKit.UIBarButtonItem.SystemItem, action: ObjectiveC.Selector)
  @objc public init(image: UIKit.UIImage, action: ObjectiveC.Selector)
  @objc public init(title: Swift.String, action: ObjectiveC.Selector)
  final public let barButtonSystemItem: UIKit.UIBarButtonItem.SystemItem?
  @objc final public let image: UIKit.UIImage?
  @objc final public let title: Swift.String?
  @objc final public let action: ObjectiveC.Selector?
  @objc deinit
}
@available(iOSApplicationExtension, unavailable)
@objc extension UIKit.UIImage {
  @objc public static func neKeyboardLeftImage() -> UIKit.UIImage?
  @objc public static func neKeyboardRightImage() -> UIKit.UIImage?
  @objc public static func neKeyboardUpImage() -> UIKit.UIImage?
  @objc public static func neKeyboardDownImage() -> UIKit.UIImage?
  @objc public static func neKeyboardPreviousImage() -> UIKit.UIImage?
  @objc public static func neKeyboardNextImage() -> UIKit.UIImage?
}
@available(iOSApplicationExtension, unavailable)
@objc extension UIKit.UIView {
  @objc @_Concurrency.MainActor @preconcurrency dynamic public var neKeyboardToolbar: NECommonUIKit.NEToolbar {
    @objc get
  }
  @objc @_Concurrency.MainActor @preconcurrency dynamic public var neShouldHideToolbarPlaceholder: Swift.Bool {
    @objc get
    @objc set(newValue)
  }
  @objc @_Concurrency.MainActor @preconcurrency dynamic public var neToolbarPlaceholder: Swift.String? {
    @objc get
    @objc set(newValue)
  }
  @objc @_Concurrency.MainActor @preconcurrency dynamic public var neDrawingToolbarPlaceholder: Swift.String? {
    @objc get
  }
  @objc @_Concurrency.MainActor @preconcurrency dynamic public func neAddKeyboardToolbarWithTarget(target: Swift.AnyObject?, titleText: Swift.String?, rightBarButtonConfiguration: NECommonUIKit.NEBarButtonItemConfiguration?, previousBarButtonConfiguration: NECommonUIKit.NEBarButtonItemConfiguration? = nil, nextBarButtonConfiguration: NECommonUIKit.NEBarButtonItemConfiguration? = nil)
  @objc @_Concurrency.MainActor @preconcurrency dynamic public func neAddDoneOnKeyboardWithTarget(_ target: Swift.AnyObject?, action: ObjectiveC.Selector, shouldShowPlaceholder: Swift.Bool = false)
  @objc @_Concurrency.MainActor @preconcurrency dynamic public func neAddDoneOnKeyboardWithTarget(_ target: Swift.AnyObject?, action: ObjectiveC.Selector, titleText: Swift.String?)
  @objc @_Concurrency.MainActor @preconcurrency dynamic public func neAddRightButtonOnKeyboardWithImage(_ image: UIKit.UIImage, target: Swift.AnyObject?, action: ObjectiveC.Selector, shouldShowPlaceholder: Swift.Bool = false)
  @objc @_Concurrency.MainActor @preconcurrency dynamic public func neAddRightButtonOnKeyboardWithImage(_ image: UIKit.UIImage, target: Swift.AnyObject?, action: ObjectiveC.Selector, titleText: Swift.String?)
  @objc @_Concurrency.MainActor @preconcurrency dynamic public func neAddRightButtonOnKeyboardWithText(_ text: Swift.String, target: Swift.AnyObject?, action: ObjectiveC.Selector, shouldShowPlaceholder: Swift.Bool = false)
  @objc @_Concurrency.MainActor @preconcurrency dynamic public func neAddRightButtonOnKeyboardWithText(_ text: Swift.String, target: Swift.AnyObject?, action: ObjectiveC.Selector, titleText: Swift.String?)
  @objc @_Concurrency.MainActor @preconcurrency dynamic public func neAddCancelDoneOnKeyboardWithTarget(_ target: Swift.AnyObject?, cancelAction: ObjectiveC.Selector, doneAction: ObjectiveC.Selector, shouldShowPlaceholder: Swift.Bool = false)
  @objc @_Concurrency.MainActor @preconcurrency dynamic public func neAddRightLeftOnKeyboardWithTarget(_ target: Swift.AnyObject?, leftButtonTitle: Swift.String, rightButtonTitle: Swift.String, leftButtonAction: ObjectiveC.Selector, rightButtonAction: ObjectiveC.Selector, shouldShowPlaceholder: Swift.Bool = false)
  @objc @_Concurrency.MainActor @preconcurrency dynamic public func neAddRightLeftOnKeyboardWithTarget(_ target: Swift.AnyObject?, leftButtonImage: UIKit.UIImage, rightButtonImage: UIKit.UIImage, leftButtonAction: ObjectiveC.Selector, rightButtonAction: ObjectiveC.Selector, shouldShowPlaceholder: Swift.Bool = false)
  @objc @_Concurrency.MainActor @preconcurrency dynamic public func neAddCancelDoneOnKeyboardWithTarget(_ target: Swift.AnyObject?, cancelAction: ObjectiveC.Selector, doneAction: ObjectiveC.Selector, titleText: Swift.String?)
  @objc @_Concurrency.MainActor @preconcurrency dynamic public func neAddRightLeftOnKeyboardWithTarget(_ target: Swift.AnyObject?, leftButtonTitle: Swift.String, rightButtonTitle: Swift.String, leftButtonAction: ObjectiveC.Selector, rightButtonAction: ObjectiveC.Selector, titleText: Swift.String?)
  @objc @_Concurrency.MainActor @preconcurrency dynamic public func neAddRightLeftOnKeyboardWithTarget(_ target: Swift.AnyObject?, leftButtonImage: UIKit.UIImage, rightButtonImage: UIKit.UIImage, leftButtonAction: ObjectiveC.Selector, rightButtonAction: ObjectiveC.Selector, titleText: Swift.String?)
  @objc @_Concurrency.MainActor @preconcurrency dynamic public func neAddPreviousNextDoneOnKeyboardWithTarget(_ target: Swift.AnyObject?, previousAction: ObjectiveC.Selector, nextAction: ObjectiveC.Selector, doneAction: ObjectiveC.Selector, shouldShowPlaceholder: Swift.Bool = false)
  @objc @_Concurrency.MainActor @preconcurrency dynamic public func neAddPreviousNextRightOnKeyboardWithTarget(_ target: Swift.AnyObject?, rightButtonImage: UIKit.UIImage, previousAction: ObjectiveC.Selector, nextAction: ObjectiveC.Selector, rightButtonAction: ObjectiveC.Selector, shouldShowPlaceholder: Swift.Bool = false)
  @objc @_Concurrency.MainActor @preconcurrency dynamic public func neAddPreviousNextRightOnKeyboardWithTarget(_ target: Swift.AnyObject?, rightButtonTitle: Swift.String, previousAction: ObjectiveC.Selector, nextAction: ObjectiveC.Selector, rightButtonAction: ObjectiveC.Selector, shouldShowPlaceholder: Swift.Bool = false)
  @objc @_Concurrency.MainActor @preconcurrency dynamic public func neAddPreviousNextDoneOnKeyboardWithTarget(_ target: Swift.AnyObject?, previousAction: ObjectiveC.Selector, nextAction: ObjectiveC.Selector, doneAction: ObjectiveC.Selector, titleText: Swift.String?)
  @objc @_Concurrency.MainActor @preconcurrency dynamic public func neAddPreviousNextRightOnKeyboardWithTarget(_ target: Swift.AnyObject?, rightButtonImage: UIKit.UIImage, previousAction: ObjectiveC.Selector, nextAction: ObjectiveC.Selector, rightButtonAction: ObjectiveC.Selector, titleText: Swift.String?)
  @objc @_Concurrency.MainActor @preconcurrency dynamic public func neAddPreviousNextRightOnKeyboardWithTarget(_ target: Swift.AnyObject?, rightButtonTitle: Swift.String, previousAction: ObjectiveC.Selector, nextAction: ObjectiveC.Selector, rightButtonAction: ObjectiveC.Selector, titleText: Swift.String?)
}
@available(iOSApplicationExtension, unavailable)
@objc extension UIKit.UIViewController {
  @objc @_Concurrency.MainActor @preconcurrency dynamic open func neParentNEContainerViewController() -> UIKit.UIViewController?
  @objc @available(*, deprecated, message: "Due to change in core-logic of handling distance between textField and keyboard distance, this layout contraint tweak is no longer needed and things will just work out of the box regardless of constraint pinned with safeArea/layoutGuide/superview.")
  @IBOutlet @_Concurrency.MainActor @preconcurrency dynamic public var neLayoutGuideConstraint: UIKit.NSLayoutConstraint? {
    @objc get
    @objc set(newValue)
  }
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency public class NEUnderlineFocusView : UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency public var underlineColor: UIKit.UIColor {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var underlineHeight: CoreFoundation.CGFloat {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var underlineWidth: CoreFoundation.CGFloat? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var masksToBounds: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var cornerRadius: CoreFoundation.CGFloat {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @objc deinit
}
@objc @objcMembers @_Concurrency.MainActor @preconcurrency open class NEUserHeaderView : UIKit.UIImageView {
  @objc @_Concurrency.MainActor @preconcurrency public var titleLabel: UIKit.UILabel {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc @_Concurrency.MainActor @preconcurrency open func configHeadData(headUrl: Swift.String?, name: Swift.String, uid: Swift.String)
  @objc @_Concurrency.MainActor @preconcurrency open func setTitle(_ name: Swift.String)
  @objc deinit
}
public struct NELottieVector1D : Swift.Hashable, Swift.Sendable {
  public init(_ value: Swift.Double)
  public let value: Swift.Double
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: NECommonUIKit.NELottieVector1D, b: NECommonUIKit.NELottieVector1D) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct NELottieVector3D : Swift.Hashable, Swift.Sendable {
  public let x: Swift.Double
  public let y: Swift.Double
  public let z: Swift.Double
  public init(x: Swift.Double, y: Swift.Double, z: Swift.Double)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: NECommonUIKit.NELottieVector3D, b: NECommonUIKit.NELottieVector3D) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension NECommonUIKit.NELottieVector1D : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct NELottieVector2D : Swift.Codable, Swift.Hashable, Swift.Sendable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: NECommonUIKit.NELottieVector2D, b: NECommonUIKit.NELottieVector2D) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension NECommonUIKit.NELottieVector3D : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension NECommonUIKit.NELottieVector3D {
  public var pointValue: CoreFoundation.CGPoint {
    get
  }
  public var sizeValue: CoreFoundation.CGSize {
    get
  }
}
extension UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency public var left: CoreFoundation.CGFloat {
    get
    set(newLeft)
  }
  @_Concurrency.MainActor @preconcurrency public var top: CoreFoundation.CGFloat {
    get
    set(newTop)
  }
  @_Concurrency.MainActor @preconcurrency public var width: CoreFoundation.CGFloat {
    get
    set(newWidth)
  }
  @_Concurrency.MainActor @preconcurrency public var height: CoreFoundation.CGFloat {
    get
    set(newHeight)
  }
  @_Concurrency.MainActor @preconcurrency public var right: CoreFoundation.CGFloat {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var bottom: CoreFoundation.CGFloat {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var centerX: CoreFoundation.CGFloat {
    get
    set(newCenterX)
  }
  @_Concurrency.MainActor @preconcurrency public var centerY: CoreFoundation.CGFloat {
    get
    set(newCenterY)
  }
  @_Concurrency.MainActor @preconcurrency public func addCorner(conrners: UIKit.UIRectCorner, radius: CoreFoundation.CGFloat)
}
extension UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency public func getLayoutConstraint(firstItem: UIKit.UIView, seconedItem: UIKit.UIView?, attribute: UIKit.NSLayoutConstraint.Attribute) -> UIKit.NSLayoutConstraint?
  @_Concurrency.MainActor @preconcurrency public func updateLayoutConstraint(firstItem: UIKit.UIView, secondItem: UIKit.UIView?, attribute: UIKit.NSLayoutConstraint.Attribute, constant: CoreFoundation.CGFloat)
  @_Concurrency.MainActor @preconcurrency public func removeLayoutConstraint(firstItem: UIKit.UIView, seconedItem: UIKit.UIView?, attribute: UIKit.NSLayoutConstraint.Attribute)
}
extension UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency public func findLabel(with string: Swift.String?) -> UIKit.UILabel?
}
@objc @_hasMissingDesignatedInitializers @objcMembers @_Concurrency.MainActor @preconcurrency public class NEWKWebViewController : NECommonUIKit.NEBaseViewController {
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidLoad()
  @objc @_Concurrency.MainActor @preconcurrency public init(url: Swift.String, title: Swift.String)
  @objc deinit
}
extension NECommonUIKit.NEWKWebViewController : WebKit.WKNavigationDelegate {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func webView(_ webView: WebKit.WKWebView, didFailProvisionalNavigation navigation: WebKit.WKNavigation!, withError error: any Swift.Error)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func webView(_ webView: WebKit.WKWebView, didFail navigation: WebKit.WKNavigation!, withError error: any Swift.Error)
}
@objc @_Concurrency.MainActor @preconcurrency open class PhotoBrowserBigImgBackView : UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency public init(urlArr: [Swift.String], number: Swift.Int)
  @_Concurrency.MainActor @preconcurrency public init(imgArr: [UIKit.UIImage], number: Swift.Int)
  @_Concurrency.MainActor @preconcurrency public func currentIndex() -> Swift.Int
  @_Concurrency.MainActor @preconcurrency public func currentImageData()
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
}
extension NECommonUIKit.PhotoBrowserBigImgBackView : UIKit.UICollectionViewDelegate, UIKit.UICollectionViewDataSource {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, numberOfItemsInSection section: Swift.Int) -> Swift.Int
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, cellForItemAt indexPath: Foundation.IndexPath) -> UIKit.UICollectionViewCell
  @_Concurrency.MainActor @preconcurrency public func dismissPhotoBrowser()
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func scrollViewDidEndDecelerating(_ scrollView: UIKit.UIScrollView)
}
extension NECommonUIKit.PhotoBrowserBigImgBackView {
  @_Concurrency.MainActor @preconcurrency public func transformAnimation()
}
extension NECommonUIKit.PhotoBrowserBigImgBackView : QuartzCore.CAAnimationDelegate {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func animationDidStop(_ anim: QuartzCore.CAAnimation, finished flag: Swift.Bool)
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objcMembers @_Concurrency.MainActor @preconcurrency open class PhotoBrowserCell : UIKit.UICollectionViewCell {
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
extension NECommonUIKit.PhotoBrowserCell : UIKit.UIScrollViewDelegate {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func viewForZooming(in scrollView: UIKit.UIScrollView) -> UIKit.UIView?
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func scrollViewDidEndZooming(_ scrollView: UIKit.UIScrollView, with view: UIKit.UIView?, atScale scale: CoreFoundation.CGFloat)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func scrollViewWillBeginZooming(_ scrollView: UIKit.UIScrollView, with view: UIKit.UIView?)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func scrollViewDidZoom(_ scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func scrollViewDidEndDecelerating(_ scrollView: UIKit.UIScrollView)
}
extension NECommonUIKit.PhotoBrowserCell : UIKit.UIGestureRecognizerDelegate {
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func gestureRecognizerShouldBegin(_ gestureRecognizer: UIKit.UIGestureRecognizer) -> Swift.Bool
}
@objc @objcMembers @_Concurrency.MainActor @preconcurrency open class PhotoBrowserController : UIKit.UIViewController {
  @objc @_Concurrency.MainActor @preconcurrency public var toolsBar: NECommonUIKit.BrowserToolsBar {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency public var successView: NECommonUIKit.ToastImageView {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency public init(imgs: [UIKit.UIImage], img: UIKit.UIImage)
  @objc @_Concurrency.MainActor @preconcurrency public init(urls: [Swift.String], url: Swift.String)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func viewDidLoad()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewWillAppear(_ animated: Swift.Bool)
  @objc deinit
}
extension NECommonUIKit.PhotoBrowserController : NECommonUIKit.BrowserToolsBarDelegate {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func didCloseClick()
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func didSaveClick()
}
@objc @_inheritsConvenienceInitializers @objcMembers @_Concurrency.MainActor @preconcurrency open class PhotoBrowserFlowLayout : UIKit.UICollectionViewFlowLayout {
  @objc @_Concurrency.MainActor @preconcurrency public var lastOffset: CoreFoundation.CGPoint
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init()
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func prepare()
  @objc deinit
}
extension NECommonUIKit.PhotoBrowserFlowLayout {
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func targetContentOffset(forProposedContentOffset proposedContentOffset: CoreFoundation.CGPoint, withScrollingVelocity velocity: CoreFoundation.CGPoint) -> CoreFoundation.CGPoint
}
public enum PopoverOption {
  case arrowSize(CoreFoundation.CGSize)
  case animationIn(Foundation.TimeInterval)
  case animationOut(Foundation.TimeInterval)
  case cornerRadius(CoreFoundation.CGFloat)
  case sideEdge(CoreFoundation.CGFloat)
  case blackOverlayColor(UIKit.UIColor)
  case overlayBlur(UIKit.UIBlurEffect.Style)
  case type(NECommonUIKit.PopoverType)
  case color(UIKit.UIColor)
  case dismissOnBlackOverlayTap(Swift.Bool)
  case showBlackOverlay(Swift.Bool)
  case springDamping(CoreFoundation.CGFloat)
  case initialSpringVelocity(CoreFoundation.CGFloat)
  case sideOffset(CoreFoundation.CGFloat)
  case borderColor(UIKit.UIColor)
}
@objc public enum PopoverType : Swift.Int {
  case up
  case down
  case left
  case right
  case auto
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc @objcMembers @_Concurrency.MainActor @preconcurrency open class Popover : UIKit.UIView {
  @objc @_Concurrency.MainActor @preconcurrency open var arrowSize: CoreFoundation.CGSize
  @objc @_Concurrency.MainActor @preconcurrency open var animationIn: Swift.Double
  @objc @_Concurrency.MainActor @preconcurrency open var animationOut: Swift.Double
  @objc @_Concurrency.MainActor @preconcurrency open var cornerRadius: CoreFoundation.CGFloat
  @objc @_Concurrency.MainActor @preconcurrency open var sideEdge: CoreFoundation.CGFloat
  @objc @_Concurrency.MainActor @preconcurrency open var popoverType: NECommonUIKit.PopoverType
  @objc @_Concurrency.MainActor @preconcurrency open var blackOverlayColor: UIKit.UIColor
  @objc @_Concurrency.MainActor @preconcurrency open var overlayBlur: UIKit.UIBlurEffect?
  @objc @_Concurrency.MainActor @preconcurrency open var popoverColor: UIKit.UIColor
  @objc @_Concurrency.MainActor @preconcurrency open var dismissOnBlackOverlayTap: Swift.Bool
  @objc @_Concurrency.MainActor @preconcurrency open var showBlackOverlay: Swift.Bool
  @objc @_Concurrency.MainActor @preconcurrency open var highlightFromView: Swift.Bool
  @objc @_Concurrency.MainActor @preconcurrency open var highlightCornerRadius: CoreFoundation.CGFloat
  @objc @_Concurrency.MainActor @preconcurrency open var springDamping: CoreFoundation.CGFloat
  @objc @_Concurrency.MainActor @preconcurrency open var initialSpringVelocity: CoreFoundation.CGFloat
  @objc @_Concurrency.MainActor @preconcurrency open var sideOffset: CoreFoundation.CGFloat
  @objc @_Concurrency.MainActor @preconcurrency open var borderColor: UIKit.UIColor?
  @objc @_Concurrency.MainActor @preconcurrency open var willShowHandler: (() -> Swift.Void)?
  @objc @_Concurrency.MainActor @preconcurrency open var willDismissHandler: (() -> Swift.Void)?
  @objc @_Concurrency.MainActor @preconcurrency open var didShowHandler: (() -> Swift.Void)?
  @objc @_Concurrency.MainActor @preconcurrency open var didDismissHandler: (() -> Swift.Void)?
  @objc @_Concurrency.MainActor @preconcurrency public var blackOverlay: UIKit.UIControl {
    get
  }
  @_Concurrency.MainActor @preconcurrency @objc dynamic public init()
  @objc @_Concurrency.MainActor @preconcurrency public init(showHandler: (() -> Swift.Void)?, dismissHandler: (() -> Swift.Void)?)
  @_Concurrency.MainActor @preconcurrency public init(options: [NECommonUIKit.PopoverOption]?, showHandler: (() -> Swift.Void)? = nil, dismissHandler: (() -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func layoutSubviews()
  @objc @_Concurrency.MainActor @preconcurrency open func showAsDialog(_ contentView: UIKit.UIView)
  @objc @_Concurrency.MainActor @preconcurrency open func showAsDialog(_ contentView: UIKit.UIView, inView: UIKit.UIView)
  @objc @_Concurrency.MainActor @preconcurrency open func show(_ contentView: UIKit.UIView, fromView: UIKit.UIView)
  @objc @_Concurrency.MainActor @preconcurrency open func show(_ contentView: UIKit.UIView, fromView: UIKit.UIView, inView: UIKit.UIView)
  @objc @_Concurrency.MainActor @preconcurrency open func show(_ contentView: UIKit.UIView, point: CoreFoundation.CGPoint)
  @objc @_Concurrency.MainActor @preconcurrency open func show(_ contentView: UIKit.UIView, point: CoreFoundation.CGPoint, inView: UIKit.UIView)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func accessibilityPerformEscape() -> Swift.Bool
  @objc @_Concurrency.MainActor @preconcurrency open func dismiss()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func draw(_ rect: CoreFoundation.CGRect)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @objcMembers @_Concurrency.MainActor @preconcurrency open class RedAngleLabel : UIKit.UILabel {
  @objc @_Concurrency.MainActor @preconcurrency public var textInsets: UIKit.UIEdgeInsets
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func drawText(in rect: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func textRect(forBounds bounds: CoreFoundation.CGRect, limitedToNumberOfLines numberOfLines: Swift.Int) -> CoreFoundation.CGRect
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @objcMembers @_Concurrency.MainActor @preconcurrency open class SearchTextField : UIKit.UITextField {
  @_Concurrency.MainActor @preconcurrency public var leftViewRectX: CoreFoundation.CGFloat?
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func leftViewRect(forBounds bounds: CoreFoundation.CGRect) -> CoreFoundation.CGRect
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func placeholderRect(forBounds bounds: CoreFoundation.CGRect) -> CoreFoundation.CGRect
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func editingRect(forBounds bounds: CoreFoundation.CGRect) -> CoreFoundation.CGRect
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func textRect(forBounds bounds: CoreFoundation.CGRect) -> CoreFoundation.CGRect
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
extension Swift.String {
  public static func stringFromTimeInterval(time: Foundation.TimeInterval) -> Swift.String
  public static func stringFromDate(date: Foundation.Date) -> Swift.String
  public static func date24To12(_ string: Swift.String?) -> Swift.String
  public static func firstDayInYear() -> Foundation.Date?
}
extension UIKit.UITabBar {
  @_Concurrency.MainActor @preconcurrency public func showBadgOn(index itemIndex: Swift.Int, tabbarItemNums: CoreFoundation.CGFloat = 4.0)
  @_Concurrency.MainActor @preconcurrency public func setRedDotView(index ItemIndex: Swift.Int)
  @_Concurrency.MainActor @preconcurrency public func hideRedDocView(index ItemIndex: Swift.Int)
  @_Concurrency.MainActor @preconcurrency public func hideBadg(on itemIndex: Swift.Int)
  @_Concurrency.MainActor @preconcurrency public func setServerBadge(count: Swift.String?)
}
@objc public protocol TabNavigationViewDelegate {
  @objc func didClickAddBtn()
  @objc func searchAction()
}
@objc @_inheritsConvenienceInitializers @objcMembers @_Concurrency.MainActor @preconcurrency open class TabNavigationView : UIKit.UIView {
  @objc @_Concurrency.MainActor @preconcurrency weak public var delegate: (any NECommonUIKit.TabNavigationViewDelegate)?
  @objc @_Concurrency.MainActor @preconcurrency public var titleBarBottomLineHeight: Swift.Double
  @objc @_Concurrency.MainActor @preconcurrency public var brandBtn: UIKit.UIButton {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency public var navigationTitle: UIKit.UILabel {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency public var searchBtn: UIKit.UIButton {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency public var addBtn: NECommonUIKit.ExpandButton {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency public var titleBarView: UIKit.UIView {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency public var titleBarBottomLine: UIKit.UIView {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc @_Concurrency.MainActor @preconcurrency open func setupSubviews()
  @objc deinit
}
extension NECommonUIKit.TabNavigationView {
  @objc @_Concurrency.MainActor @preconcurrency dynamic open func searchBtnClick(sender: UIKit.UIButton)
  @objc @_Concurrency.MainActor @preconcurrency dynamic open func addBtnClick(sender: UIKit.UIButton)
}
@objc @_inheritsConvenienceInitializers @objcMembers @_Concurrency.MainActor @preconcurrency open class TextBaseCell : UIKit.UITableViewCell {
  @objc @_Concurrency.MainActor @preconcurrency public var titleLabelTopAnchor: UIKit.NSLayoutConstraint?
  @objc @_Concurrency.MainActor @preconcurrency public var titleLabelCenterYAnchor: UIKit.NSLayoutConstraint?
  @objc @_Concurrency.MainActor @preconcurrency public var headImageView: NECommonUIKit.NEUserHeaderView {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency public var titleLabel: UIKit.UILabel {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency public var subTitleLabel: UIKit.UILabel {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func awakeFromNib()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func setSelected(_ selected: Swift.Bool, animated: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(style: UIKit.UITableViewCell.CellStyle, reuseIdentifier: Swift.String?)
  @objc @_Concurrency.MainActor @preconcurrency open func setupSubviews()
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @objcMembers @_Concurrency.MainActor @preconcurrency open class ToastImageView : UIKit.UIView {
  @objc @_Concurrency.MainActor @preconcurrency public var imageView: UIKit.UIImageView
  @objc @_Concurrency.MainActor @preconcurrency public var contentLabel: UIKit.UILabel
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
extension UIKit.UIAlertController {
  @_Concurrency.MainActor @preconcurrency public func fixIpadAction()
}
@objc @objcMembers @_Concurrency.MainActor @preconcurrency open class CornerView : UIKit.UIView {
  @objc @_Concurrency.MainActor @preconcurrency public init(corner: UIKit.UIRectCorner, radius: CoreFoundation.CGFloat = 8, color: UIKit.UIColor = .white)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func draw(_ rect: CoreFoundation.CGRect)
  @objc deinit
}
extension UIKit.UIImageView {
  @_Concurrency.MainActor @preconcurrency public func addCustomCorner(conrners: UIKit.UIRectCorner, radius: CoreFoundation.CGFloat, backcolor: UIKit.UIColor)
  @_Concurrency.MainActor @preconcurrency public func removeAllCustomCorner()
}
extension UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency public var isVisibleInWindow: Swift.Bool {
    get
  }
}
@_inheritsConvenienceInitializers @objc @objcMembers @_Concurrency.MainActor @preconcurrency open class VideoPlayerViewController : UIKit.UIViewController {
  @objc @_Concurrency.MainActor @preconcurrency public var videoUrl: Foundation.URL?
  @_Concurrency.MainActor @preconcurrency public var totalTime: Swift.Int?
  @objc @_Concurrency.MainActor @preconcurrency public var playButton: NECommonUIKit.ExpandButton {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency public var toolsBar: NECommonUIKit.BrowserToolsBar {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency public var successView: NECommonUIKit.ToastImageView {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency public var videoToolBar: NECommonUIKit.VideoToolBar {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidLoad()
  @objc deinit
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
}
extension NECommonUIKit.VideoPlayerViewController : NECommonUIKit.BrowserToolsBarDelegate, UIKit.UINavigationControllerDelegate, UIKit.UIImagePickerControllerDelegate {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func didCloseClick()
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func didSaveClick()
  @objc @_Concurrency.MainActor @preconcurrency dynamic public func endPlay()
}
@objc public enum VideoState : Swift.Int {
  case VideoPlay = 1
  case VideoDownload
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc @_inheritsConvenienceInitializers @objcMembers @_Concurrency.MainActor @preconcurrency open class VideoStateView : UIKit.UIView {
  @objc @_Concurrency.MainActor @preconcurrency public var state: NECommonUIKit.VideoState {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc @_Concurrency.MainActor @preconcurrency open func setProgress(_ progress: Swift.Float)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_Concurrency.MainActor @preconcurrency public class VideoToolBar : UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency public var playButton: NECommonUIKit.ExpandButton {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var currentTimeLabel: UIKit.UILabel {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var totalTimeLabel: UIKit.UILabel {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var progressSlider: UIKit.UISlider {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public func resetState()
  @objc deinit
}
public typealias AlertCallBack = () -> Swift.Void
extension UIKit.UIViewController {
  @_Concurrency.MainActor @preconcurrency public var rightNavButton: NECommonUIKit.ExpandButton {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var leftNavButton: NECommonUIKit.ExpandButton {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public func addLeftAction(_ image: UIKit.UIImage?, _ selector: ObjectiveC.Selector, _ target: Any?, _ tintColor: UIKit.UIColor = .ne_greyText)
  @_Concurrency.MainActor @preconcurrency public func addLeftAction(_ title: Swift.String, _ selector: ObjectiveC.Selector, _ target: Any?, _ tintColor: UIKit.UIColor = UIColor.ne_normalTheme)
  @_Concurrency.MainActor @preconcurrency public func addRightAction(_ image: UIKit.UIImage?, _ selector: ObjectiveC.Selector, _ target: Any?, _ tintColor: UIKit.UIColor = .ne_greyText)
  @_Concurrency.MainActor @preconcurrency public func addRightAction(_ title: Swift.String, _ selector: ObjectiveC.Selector, _ target: Any?, _ tintColor: UIKit.UIColor = UIColor.ne_normalTheme)
  @_Concurrency.MainActor @preconcurrency public func showAlert(title: Swift.String = commonLocalizable("tip"), message: Swift.String?, sureText: Swift.String = commonLocalizable("sure"), cancelText: Swift.String = commonLocalizable("cancel"), sureTextColor: UIKit.UIColor? = nil, canceTextColor: UIKit.UIColor? = nil, sureBack: @escaping NECommonUIKit.AlertCallBack, cancelBack: NECommonUIKit.AlertCallBack? = nil)
  @_Concurrency.MainActor @preconcurrency public func showSingleAlert(title: Swift.String = commonLocalizable("tip"), message: Swift.String?, sureText: Swift.String = commonLocalizable("sure"), _ sureBack: @escaping NECommonUIKit.AlertCallBack)
  @_Concurrency.MainActor @preconcurrency public func showToast(_ message: Swift.String, _ position: NECommonUIKit.ToastPosition = .center)
  @_Concurrency.MainActor @preconcurrency public func showToastInWindow(_ message: Swift.String)
  @_Concurrency.MainActor @preconcurrency public func showActionSheet(_ actions: [UIKit.UIAlertAction])
  @_Concurrency.MainActor @preconcurrency public func showCustomActionSheet(_ actions: [NECommonUIKit.NECustomAlertAction])
  @_Concurrency.MainActor @preconcurrency public func showBottomVideoAction(_ delegate: any UIKit.UIImagePickerControllerDelegate & UIKit.UINavigationControllerDelegate, _ editing: Swift.Bool = true)
  @_Concurrency.MainActor @preconcurrency public func showCustomBottomVideoAction(_ delegate: any UIKit.UIImagePickerControllerDelegate & UIKit.UINavigationControllerDelegate, _ editing: Swift.Bool = true)
  @_Concurrency.MainActor @preconcurrency public func showBottomFileAction(_ delegate: any UIKit.UIDocumentPickerDelegate & UIKit.UIImagePickerControllerDelegate & UIKit.UINavigationControllerDelegate)
  @_Concurrency.MainActor @preconcurrency public func showCustomBottomFileAction(_ delegate: any UIKit.UIDocumentPickerDelegate & UIKit.UIImagePickerControllerDelegate & UIKit.UINavigationControllerDelegate)
  @_Concurrency.MainActor @preconcurrency public func showBottomTelAction(_ url: Foundation.URL)
  @_Concurrency.MainActor @preconcurrency public func showCustomBottomTelAction(_ url: Foundation.URL)
  @_Concurrency.MainActor @preconcurrency public func showBottomMailAction(_ url: Foundation.URL)
  @_Concurrency.MainActor @preconcurrency public func showCustomBottomMailAction(_ url: Foundation.URL)
  @_Concurrency.MainActor @preconcurrency public func fixAlertOnIpad(_ alertViewController: UIKit.UIAlertController)
  @_Concurrency.MainActor @preconcurrency public func showBottomAlert(_ delegate: any UIKit.UIImagePickerControllerDelegate & UIKit.UINavigationControllerDelegate, _ editing: Swift.Bool = true, _ checkNetwork: Swift.Bool = true, _ clickedAction: (() -> Swift.Void)? = nil, _ presentCompletion: (() -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency public func showCustomBottomAlert(_ delegate: any UIKit.UIImagePickerControllerDelegate & UIKit.UINavigationControllerDelegate, _ editing: Swift.Bool = true, _ checkNetwork: Swift.Bool = true)
  @_Concurrency.MainActor @preconcurrency public func showBottomSelectAlert(firstContent: Swift.String, secondContent: Swift.String, selectValue: @escaping ((_ value: ObjectiveC.NSInteger) -> Swift.Void))
  @_Concurrency.MainActor @preconcurrency public func goCamera(_ delegate: any UIKit.UIImagePickerControllerDelegate & UIKit.UINavigationControllerDelegate, _ editing: Swift.Bool, _ isVideo: Swift.Bool = false)
  @_Concurrency.MainActor @preconcurrency public func goPhotoAlbum(_ delegate: any UIKit.UIImagePickerControllerDelegate & UIKit.UINavigationControllerDelegate, _ editing: Swift.Bool, _ isVideo: Swift.Bool = false)
  @_Concurrency.MainActor @preconcurrency public func showPicker(_ delegate: any UIKit.UIImagePickerControllerDelegate & UIKit.UINavigationControllerDelegate, _ isVideo: Swift.Bool, _ editing: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency public func goPhotoAlbumWithVideo(_ delegate: any UIKit.UIImagePickerControllerDelegate & UIKit.UINavigationControllerDelegate, _ completion: (() -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency public func goICloudDocument(_ delegate: any UIKit.UIDocumentPickerDelegate & UIKit.UINavigationControllerDelegate)
}
extension NECommonUIKit.FileState : Swift.Equatable {}
extension NECommonUIKit.FileState : Swift.Hashable {}
extension NECommonUIKit.FileState : Swift.RawRepresentable {}
extension NECommonUIKit.NEAnimatedSwitch.NECancelBehavior : Swift.Equatable {}
extension NECommonUIKit.NEAnimatedSwitch.NECancelBehavior : Swift.Hashable {}
extension NECommonUIKit.NEBlendMode : Swift.Equatable {}
extension NECommonUIKit.NEBlendMode : Swift.Hashable {}
extension NECommonUIKit.NEBlendMode : Swift.RawRepresentable {}
extension NECommonUIKit.ButtonStyle : Swift.Equatable {}
extension NECommonUIKit.ButtonStyle : Swift.Hashable {}
extension NECommonUIKit.NEColorValueProvider : NECommonUIKit.NEAnyValueProvider {}
extension NECommonUIKit.NECompatibleRenderingEngineOption : Swift.Equatable {}
extension NECommonUIKit.NECompatibleRenderingEngineOption : Swift.Hashable {}
extension NECommonUIKit.NECompatibleRenderingEngineOption : Swift.RawRepresentable {}
extension NECommonUIKit.NECompatibleBackgroundBehavior : Swift.Equatable {}
extension NECommonUIKit.NECompatibleBackgroundBehavior : Swift.Hashable {}
extension NECommonUIKit.NECompatibleBackgroundBehavior : Swift.RawRepresentable {}
extension NECommonUIKit.NEFloatValueProvider : NECommonUIKit.NEAnyValueProvider {}
extension NECommonUIKit.NEGradientValueProvider : NECommonUIKit.NEAnyValueProvider {}
extension NECommonUIKit.NEInvalidationState : Swift.Equatable {}
extension NECommonUIKit.NEInvalidationState : Swift.Hashable {}
@available(iOSApplicationExtension, unavailable)
extension NECommonUIKit.NEAutoToolbarManageBehaviour : Swift.Equatable {}
@available(iOSApplicationExtension, unavailable)
extension NECommonUIKit.NEAutoToolbarManageBehaviour : Swift.Hashable {}
@available(iOSApplicationExtension, unavailable)
extension NECommonUIKit.NEAutoToolbarManageBehaviour : Swift.RawRepresentable {}
@available(iOSApplicationExtension, unavailable)
extension NECommonUIKit.NEPreviousNextDisplayMode : Swift.Equatable {}
@available(iOSApplicationExtension, unavailable)
extension NECommonUIKit.NEPreviousNextDisplayMode : Swift.Hashable {}
@available(iOSApplicationExtension, unavailable)
extension NECommonUIKit.NEPreviousNextDisplayMode : Swift.RawRepresentable {}
@available(iOSApplicationExtension, unavailable)
extension NECommonUIKit.NEEnableMode : Swift.Equatable {}
@available(iOSApplicationExtension, unavailable)
extension NECommonUIKit.NEEnableMode : Swift.Hashable {}
@available(iOSApplicationExtension, unavailable)
extension NECommonUIKit.NEEnableMode : Swift.RawRepresentable {}
extension NECommonUIKit.NELayerType : Swift.Equatable {}
extension NECommonUIKit.NELayerType : Swift.Hashable {}
extension NECommonUIKit.NELayerType : Swift.RawRepresentable {}
extension NECommonUIKit.NEMatteType : Swift.Equatable {}
extension NECommonUIKit.NEMatteType : Swift.Hashable {}
extension NECommonUIKit.NEMatteType : Swift.RawRepresentable {}
extension NECommonUIKit.NECoordinateSpace : Swift.Equatable {}
extension NECommonUIKit.NECoordinateSpace : Swift.Hashable {}
extension NECommonUIKit.NECoordinateSpace : Swift.RawRepresentable {}
extension NECommonUIKit.NELottieBackgroundBehavior : Swift.Equatable {}
extension NECommonUIKit.NELottieBackgroundBehavior : Swift.Hashable {}
@available(iOS 13.0, tvOS 13.0, macOS 10.15, *)
extension NECommonUIKit.NELottieButton : SwiftUICore.View {}
@available(iOS 13.0, tvOS 13.0, macOS 10.15, *)
extension NECommonUIKit.NELottieButton : Swift.Sendable {}
@available(iOS 13.0, tvOS 13.0, macOS 10.15, *)
extension NECommonUIKit.NELottieSwitch : SwiftUICore.View {}
@available(iOS 13.0, tvOS 13.0, macOS 10.15, *)
extension NECommonUIKit.NELottieSwitch : Swift.Sendable {}
@available(iOS 13.0, tvOS 13.0, macOS 10.15, *)
extension NECommonUIKit.NELottieView : SwiftUICore.View {}
@available(iOS 13.0, tvOS 13.0, macOS 10.15, *)
extension NECommonUIKit.NELottieView : Swift.Sendable {}
extension NECommonUIKit.NEPageViewDirection : Swift.Equatable {}
extension NECommonUIKit.NEPageViewDirection : Swift.Hashable {}
extension NECommonUIKit.PagingContentInteraction : Swift.Equatable {}
extension NECommonUIKit.PagingContentInteraction : Swift.Hashable {}
extension NECommonUIKit.NEPagingMenuHorizontalAlignment : Swift.Equatable {}
extension NECommonUIKit.NEPagingMenuHorizontalAlignment : Swift.Hashable {}
extension NECommonUIKit.PagingMenuInteraction : Swift.Equatable {}
extension NECommonUIKit.PagingMenuInteraction : Swift.Hashable {}
extension NECommonUIKit.NEPagingMenuPosition : Swift.Equatable {}
extension NECommonUIKit.NEPagingMenuPosition : Swift.Hashable {}
extension NECommonUIKit.NEPagingMenuTransition : Swift.Equatable {}
extension NECommonUIKit.NEPagingMenuTransition : Swift.Hashable {}
extension NECommonUIKit.NEPagingNavigationOrientation : Swift.Equatable {}
extension NECommonUIKit.NEPagingNavigationOrientation : Swift.Hashable {}
extension NECommonUIKit.NEPagingSelectedScrollPosition : Swift.Equatable {}
extension NECommonUIKit.NEPagingSelectedScrollPosition : Swift.Hashable {}
extension NECommonUIKit.NEPointValueProvider : NECommonUIKit.NEAnyValueProvider {}
extension NECommonUIKit.NESizeValueProvider : NECommonUIKit.NEAnyValueProvider {}
extension NECommonUIKit.NETabPagingMenuView.Alignment : Swift.Equatable {}
extension NECommonUIKit.NETabPagingMenuView.Alignment : Swift.Hashable {}
extension NECommonUIKit.ToastPosition : Swift.Equatable {}
extension NECommonUIKit.ToastPosition : Swift.Hashable {}
extension NECommonUIKit.PopoverType : Swift.Equatable {}
extension NECommonUIKit.PopoverType : Swift.Hashable {}
extension NECommonUIKit.PopoverType : Swift.RawRepresentable {}
extension NECommonUIKit.VideoState : Swift.Equatable {}
extension NECommonUIKit.VideoState : Swift.Hashable {}
extension NECommonUIKit.VideoState : Swift.RawRepresentable {}
